{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"339719ac-3b23-537b-9636-f8515175af2f","excerpt":"在前端开发中，如何对前端状态的管理是一个需要面对的问题，前端主要是数据展示和界面交互， 交互的存在就会导致数据的变化，数据的变化会影响页面的展示 ，也就是说，一个完整的前端状态管理，要提供数据的存储、更新、数据变化的通知机制。这篇文章，我们来了解一下如何从0到1，如何实现前端数据的管理。 发布订阅 首先我们需要一个机制在数据更新的时候，用到这份数据的部分能够知道数据更新了，这样才能保证页面的同步；这里我们需要实现一个 Publish/Subscribe ，在数据更新的时候发布 stateChanged 的事件，所有订阅了 stateChange…","html":"<p>在前端开发中，如何对前端状态的管理是一个需要面对的问题，前端主要是数据展示和界面交互，<strong><em>交互的存在就会导致数据的变化，数据的变化会影响页面的展示</em></strong>，也就是说，一个完整的前端状态管理，要提供数据的存储、更新、数据变化的通知机制。这篇文章，我们来了解一下如何从0到1，如何实现前端数据的管理。</p>\n<h2>发布订阅</h2>\n<p>首先我们需要一个机制在数据更新的时候，用到这份数据的部分能够知道数据更新了，这样才能保证页面的同步；这里我们需要实现一个<a href=\"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">Publish/Subscribe</a>，在数据更新的时候发布<code>stateChanged</code>的事件，所有订阅了<code>stateChange</code>的组件会调用注册的回调函数来获取更新后的数据。</p>\n<pre><code class=\"language-javascript\">// ------pubSub.js------\nexport default class PubSub {\n  constructor(){\n    this.listeners = {};\n  }\n  publish(event, data) {\n    const currentEventListeners = this.listeners[event];\n    if (currentEventListeners) {\n      currentEventListeners.forEach(listener => {\n        listener(data);\n      });\n    } \n  }\n  \n  subscribe(event, callback) {\n    if (typeof callback !== 'function') {\n      throw Error('callback is not a function!');\n    }\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n  }\n}\n</code></pre>\n<p>如上，就是一个发布／订阅的简单实现，<code>listeners</code>中会维护所有注册的回调函数，在<code>subscribe</code>的时候会以事件名为<code>key</code>，回调函数为<code>value</code>，放入<code>listeners</code>中，<code>publish</code>事件的时候，会调用注册到当前这个事件所有的回调函数。<code>发布／订阅</code>模式是很常见的消息传递机制，好处是模块与模块之间解耦，订阅者和发布者对于彼此是透明的。</p>\n<h2>如何侦测数据变更</h2>\n<p>有了发布／订阅之后，我们就需要知道数据变更的时机，这里我们使用<code>ES6</code>的<code>Proxy</code>来检测数据的变化。</p>\n<pre><code class=\"language-javascript\">// --- store.js---\nthis.state = new Proxy(params.state || {}, {\n  set: (state, key, value) => {\n    state[key] = value;\n    this.events.publish('stateChanged', this.state);\n    if (this.status !== Status.Mutating) {\n      console.warn('You Should Mutate Your State By Action!');\n    }\n    this.status = Status.Resting;\n    return true;\n  }\n</code></pre>\n<p>如上，<code>store</code>中的<code>state</code>是一个<code>Proxy</code>，我们在<code>set</code>数据的时候，会发布<code>stateChanged</code>的事件，所有订阅了<code>stateChanged</code>的回调都会被调用。</p>\n<h2>如何变更数据</h2>\n<p>类似于<code>redux</code>，我们需要设计一套去变更数据的模式，在创建<code>store</code>的时候，将我们对数据的加工操作（类似于<code>redux</code>的<code>reducer</code>注册进去），在需要修改数据的时候，<code>dispatch</code>对应的<code>action</code>。</p>\n<pre><code class=\"language-javascript\">export class Store {\n  constructor(params) {\n    this.events = new PubSub();\n    if (params.hasOwnProperty('mutations')) { // {A}\n      this.mutations = params.mutations;\n    };\n  }\n  commit(mutationType, payload) {\n    this.status = Status.Mutating;\n    if (typeof this.mutations[mutationType] === 'function') {\n      this.mutations[mutationType](this.state, payload);\n    }\n  }\n  dispatch(actionType, payload){\n    if (isPlainObject(payload)) {\n      throw Error('Payload Must Be A Plain Object!');\n    }\n    if (this.status === Status.Mutating) {\n      throw Error('Can Not Dispatch Action In Mutation Function!');\n    }\n    this.commit(actionType, payload); // {B}\n  }\n  getState() {\n    return this.state;\n  }\n}\n</code></pre>\n<p>在创建<code>store</code>的时候，我们将修改<code>state</code>的操作<code>mutations</code>注入进去(<code>{A}</code>行代码)，在<code>dispatch</code>的时候，根据<code>dispatch</code>的<code>action</code>的类型去调用对应的<code>mutation</code>来更改<code>state</code>，<code>mutation</code>会触发<code>stateChanged</code>的事件，这样所有订阅了<code>stateChanged</code>事件的组件会刷新；所以我们可以提供一个基础组件，这个组件要做的事就是订阅<code>stateChanged</code>事件，事件发生之后就重新渲染：</p>\n<pre><code class=\"language-javascript\">export default class Component {\n  constructor(props) {\n    if (props.store instanceof Store) {\n      this.store = props.store;\n      this.store.events.subscribe('stateChanged', (state) => this.render(state));\n    }\n    if (props.hasOwnProperty('element')) {\n      this.element = props.element;\n    }\n  }\n  render() {}\n}\n</code></pre>\n<p>如上，其他的组件从这个组件上继承的时候，就会自动订阅<code>stateChanged</code>的事件，完整的代码实现在这里：<a href=\"https://github.com/Soyn/tinyStateManager\">tinyStateManager</a></p>\n<h2>Reference</h2>\n<ul>\n<li>\n<h2><a href=\"https://css-tricks.com/build-a-state-management-system-with-vanilla-javascript/\">Build a state management system with vanilla JavaScript</a></h2>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>\n</li>\n</ul>","frontmatter":{"title":"实现一个前端状态管理库","date":"March 23, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-3-23-StateManager/","previous":{"fields":{"slug":"/2019-3-16-ESModule/"},"frontmatter":{"title":"ES6 Module","category":"Tech"}},"next":{"fields":{"slug":"/2019-4-13-frontend-route/"},"frontmatter":{"title":"前端路由","category":"Tech"}}}}