{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"f78b4726-029a-5932-bdf2-e50121f4ea54","excerpt":"上一篇博客 Javascript模块化 介绍了前端的模块化的一些方案和历史，基于浏览器的 AMD 规范 ，我们尝试自己实现一个 AMD Loader 。 AMD Loader要解决的问题 AMD 主要是为了解决浏览器端的模块化，实现 AMD Loader 的话，以下的点要考虑到： 前端的加载是异步的 模块的依赖也是模块（可能会出现循环依赖的问题） 每个Module只加载一次 AMD Loader 暴露  define 和 require 其实我们主要要解决的点在于，如何处理 Module 的加载。 Module…","html":"<p>上一篇博客<a href=\"http://cuteshilina.com/2019/02/06/Javascript%E6%A8%A1%E5%9D%97%E5%8C%96/\">Javascript模块化</a>介绍了前端的模块化的一些方案和历史，基于浏览器的<a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\"><code>AMD</code>规范</a>，我们尝试自己实现一个<code>AMD Loader</code>。</p>\n<h1>AMD Loader要解决的问题</h1>\n<p><code>AMD</code>主要是为了解决浏览器端的模块化，实现<code>AMD Loader</code>的话，以下的点要考虑到：</p>\n<ul>\n<li>前端的加载是异步的</li>\n<li>模块的依赖也是模块（可能会出现循环依赖的问题）</li>\n<li>每个Module只加载一次</li>\n<li><code>AMD Loader</code>暴露 <code>define</code>和<code>require</code></li>\n</ul>\n<p>其实我们主要要解决的点在于，如何处理<code>Module</code>的加载。<code>Module</code>加载要解决两个主要问题，一是对模块的引用（对path的处理）；二是如何维护模块之间的引用关系。</p>\n<h1>模块代码的加载</h1>\n<p>首先来看看<code>define</code>的<code>API</code>接口：</p>\n<pre><code class=\"language-javascript\">define(id?, dependence?, factory)\n</code></pre>\n<p><code>define</code>的函数中<code>id</code>是表示当前模块的<code>id</code>，<strong><code>id</code>可以是字符串或者一个绝对路径的字符串</strong>，这里规定不能出现相对<code>id</code>，例如'./myModule'或者 '../myModule'；<code>id</code>是可选的，如果没有提供<code>id</code>的话，默认<code>id</code>名是<code>Module</code>的在浏览器加载当前<code>Module</code>的<code>url</code>。\n<code>dependence</code>，是一个字符串数组，字符串是依赖模块的<code>url</code>，可以是相对路径、绝对路径、字符串（如JQuery）。\n所以，我们首先要解决的问题是，如何去规范化用户传进来的各种各样的<code>url</code>，例如，下面这些<code>url</code>的规范化：</p>\n<pre><code class=\"language-javascript\"> ./a/b/c//d --> a/b/c/d\n ./a/b/c/../../d --> ./a/d\n ./a/b/c/./d --> ./a/b/c/d\n main/test?foo#bar --> main/test\n</code></pre>\n<p>对于这些<code>URl</code>，我们可以写正则表达式去匹配，在用户传入模块的'url'，需要过一遍我们的正则，将其规范化，对于依赖模块，我们要基于当前<code>Config</code>的<code>baseURL</code>（如果在config中配置了baseUrl的话），拼成完整的<code>url</code>，让浏览器的<code>script</code>去加载，在加载完之后，将对应的<code>script</code>删除。</p>\n<pre><code class=\"language-script\">    function loadScript(url, callback) {\n        var node = document.createElement('script');\n        var head = document.head;\n        node.setAttribute('data-module', url);\n        node.async = true;\n        node.src = url;\n        \n        function onload() {\n            node.onload = node.onerror = null;\n            head.removeChild(node);\n            callback();\n        }\n        node.onerror = function(error) {\n            node.onload = node.onerror = null;\n            head.removeChild(node);\n            callback(error)\n        }\n    }\n</code></pre>\n<p>如上，是使用<code>script</code>标签加载模块的一些代码，基本逻辑是：</p>\n<p><code>创建script标签 ---> 加载模块源码 ---> 模块加载完成后触发回调函数</code></p>\n<p>这里主要是利用<code>script</code>标签来做模块的加载，这里给<code>script</code>标签加上了<code>async=true</code>的标志，浏览器在解析<code>HTML</code>页面的时候，不会因为加载<code>script</code>阻塞住页面的解析，在<code>script</code>加载成功后执行<code>script</code>中的代码。</p>\n<h1>模块的定义</h1>\n<p>在使用<code>AMD Loader</code>定义我们的<code>Module</code>的时候，使用<code>define(id?, dependence?, factory)</code>的接口来定义我们的<code>Module</code>，在实现模块定义的时候，我们可以预想到有以下问题：</p>\n<ul>\n<li>模块的加载是异步的，意味着我们需要设计<code>notify</code>机制</li>\n<li>我们需要解决模块循环依赖问题</li>\n<li>模块仅仅被加载一次，需要有模块的<code>cache</code></li>\n</ul>\n<p><img src=\"./images/main.png\">\n如上，对于<code>main Module</code>有<code>dep0, dep1, dep2</code>三个依赖，这里我们在定义<code>main Module</code>的时候，将<code>main Module</code>中的每个依赖（在声明中只有url）实例化成<code>Module</code>，在加载<code>main Module</code>的时候，得先要加载我们的依赖<code>Module</code>，这里因为<code>Module</code>的加载是异步的，所以在实例化我们的依赖的时候，在每个<code>Module</code>中保存一个<code>refs</code>的数组，这个数组中保存着依赖这个<code>Module</code>的<code>id</code>，当前<code>Module</code>加载完成之后，在<code>onload</code>的<code>callback</code>中去通知当前模块<code>load</code>完成，然后当前<code>Module</code>会查看当前<code>Module</code>的<code>refs</code>中所有的<code>Module</code>，在<code>refs</code>中这些<code>Module</code>就会收集自己所有的依赖是不是都加载完成，如果加载完成了，当前的<code>Module</code>就加载完成了，否则就触发当前<code>ref</code>的重新<code>load</code>（为了触发其他未被加载的依赖的加载）。</p>\n<p>解决了<code>notify</code>的问题，剩下的两个问题主要是对<code>Module</code>状态的维护，如下图，是整个<code>Module</code>的加载的状态转移图：\n<img src=\"./images/AMDLoader.png\"></p>\n<p>依照上图的状态转移图，<code>Module Class</code>的设计如下：</p>\n<pre><code class=\"language-javascript\">function Module(url, deps) {\n    this.refs = [];\n    this.depsUrl = getVaildUrl(deps);\n    this.depsModule = [];\n    this.STATUS = STATUS.INIT;\n}\n\nModule.prototype = {\n    constructor: Module,\n    fetch: function() {},  // 加载module的代码\n    save: function(depsUrl), // 检测修正依赖的url，并剔除已经被加载的module的url\n    resolve: function(), // 实例化每个依赖\n    setDependencies: function(), // 设置依赖当前模块的refs\n    checkCircular: function(), // 检测循环依赖\n    makeExports: function(), // 调用Module的factory函数并输出exports\n    load: function() {}, // 加载模块\n}\n</code></pre>\n<p>对于Module本身来说我们这里也需要维护一个状态，来表明当前<code>Module</code>的执行状态：</p>\n<p><code>init --> fetch --> save --> load --> executing --> executed or error</code></p>\n<p><code>AMD-Loader</code>的完整代码 --> <a href=\"https://github.com/Soyn/AMDLoader/blob/master/src/index.js\">AMD Loader</a>，<strong>代码实现仅为了解AMD模块加载的原理，并不能用在生产环境下</strong>。</p>\n<h1>Reference</h1>\n<ul>\n<li><a href=\"https://github.com/creeperyang/blog/issues/17\">AMD加载器分析与实现</a></li>\n<li><a href=\"https://github.com/creeperyang/amd-loader/blob/master/amd.js\">https://github.com/creeperyang/amd-loader/blob/master/amd.js</a></li>\n<li><a href=\"https://github.com/requirejs/requirejs/blob/master/require.js\">requireJS源码</a></li>\n</ul>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"自己动手写AMD Loader","date":"February 23, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-2-23-WriteYourOwnAmdLoader/","previous":{"fields":{"slug":"/2019-2-06-Javascript模块化/"},"frontmatter":{"title":"Javascript模块化","category":"Tech"}},"next":{"fields":{"slug":"/2019-3-2-AsyncAndDeferInScript/"},"frontmatter":{"title":"script在HTML中的加载","category":"Tech"}}}}