{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"35f1b8ba-9908-5c35-a3db-9c723509ab0d","excerpt":"TL;DR; Connect 本质上是一个高阶组件 Connect 会对组件做缓存控制 Connect 使用 Context 做全局状态的通信 Overview 如上，react-redux向外暴露了四个API，分别是 Provider 、 ConnectAdvanced 、 ReactReduxContext 、 connect 。 Provider Provider 是一个 React Component ，在组件 didMount 的时候订阅 redux 的 store ，在 willUnMount 的时候接触订阅，每次 redux state…","html":"<hr>\n<p>TL;DR;</p>\n<ul>\n<li><code>Connect</code>本质上是一个高阶组件</li>\n<li><code>Connect</code>会对组件做缓存控制</li>\n<li>\n<h2><code>Connect</code>使用<code>Context</code>做全局状态的通信</h2>\n</li>\n</ul>\n<h2>Overview</h2>\n<pre><code class=\"language-javascript\">import Provider from './components/Provider'\nimport connectAdvanced from './components/connectAdvanced'\nimport { ReactReduxContext } from './components/Context'\nimport connect from './connect/connect'\n\nexport { Provider, connectAdvanced, ReactReduxContext, connect }\n</code></pre>\n<p>如上，react-redux向外暴露了四个API，分别是<code>Provider</code>、<code>ConnectAdvanced</code>、<code>ReactReduxContext</code>、<code>connect</code>。</p>\n<h2>Provider</h2>\n<p><code>Provider</code>是一个<code>React Component</code>，在组件<code>didMount</code>的时候订阅<code>redux</code>的<code>store</code>，在<code>willUnMount</code>的时候接触订阅，每次<code>redux state</code>改变的时候，会调用<code>Provider</code>中的<code>setState</code>，使得组件刷新，我们来看看部分源代码：</p>\n<pre><code class=\"language-javascript\">    constructor(props) {\n    super(props)\n\n    const { store } = props\n\n    this.state = {\n      storeState: store.getState(),\n      store\n    }\n  }\n</code></pre>\n<p>在组件初始化的时候，<code>Provider</code>从<code>props</code>上获取<code>redux</code>上的<code>store</code>，并初始化<code>state</code>。</p>\n<p>同时在组件<code>didMount</code>的时候，这里会向<code>redux</code>的<code>store</code>上注册<code>callback</code>函数：</p>\n<pre><code class=\"language-javascript\">    componentDidMount() {\n    this._isMounted = true\n    this.subscribe()\n  }\n  subscribe() {\n    const { store } = this.props\n\n    this.unsubscribe = store.subscribe(() => {\n      const newStoreState = store.getState()\n\n      if (!this._isMounted) {\n        return\n      }\n\n      this.setState(providerState => {\n        // If the value is the same, skip the unnecessary state update.\n        if (providerState.storeState === newStoreState) {\n          return null\n        }\n\n        return { storeState: newStoreState }\n      })\n    })\n\n    // Actions might have been dispatched between render and mount - handle those\n    const postMountStoreState = store.getState()\n    if (postMountStoreState !== this.state.storeState) {\n      this.setState({ storeState: postMountStoreState })\n    }\n  }\n</code></pre>\n<p>这里在<code>subscribe</code>函数的最后几行的代码，是用来处理在组件<code>Provider</code>如果在初次<code>render</code>的时候，如果有<code>action</code>被<code>dispatch</code>，这个时候还没有<code>subscribe</code>，但是这时候我们的数据需要刷新，所以这个时候需要去取一次最新数据，如果发现有数据变化，使用<code>setState</code>，触发组件刷新。</p>\n<p>在<code>render</code>中使用<code>Context.Provider</code>将<code>context</code>中的内容，即我们这里的<code>state</code>注入到<code>children</code>组件中。</p>\n<p>从上面的代码可以看到，如果<code>redux</code>的<code>State</code>发生了变化，会触发顶层组件的刷新，重新<code>render</code>，从而重刷整个应用。</p>\n<h2>Connect</h2>\n<p><code>connect</code>这个函数就是我们经常要使用到的，一般来说在使用<code>redux</code>的时候，<code>Container</code>组件就是一个<code>connect</code>之后的组件。\n<code>connect</code>主要的工作就是一是负责从<code>state tree</code>上去取组件要用的数据，另外就是在<code>state</code>变化的时候，重新计算来自<code>state</code>上的<code>props</code>。\n我们来看看一个简单版本的<code>connect</code>的实现（<a href=\"https://gist.github.com/gaearon/1d19088790e70ac32ea636c025ba424e\">connect explain</a>）:</p>\n<pre><code class=\"language-javascript\">// connect() is a function that injects Redux-related props into your component.\n// You can inject data and callbacks that change that data by dispatching actions.\nfunction connect(mapStateToProps, mapDispatchToProps) {\n  // It lets us inject component as the last step so people can use it as a decorator.\n  // Generally you don't need to worry about it.\n  return function (WrappedComponent) {\n    // It returns a component\n    return class extends React.Component {\n      render() {\n        return (\n          // that renders your component\n          &#x3C;WrappedComponent\n            {/* with its props  */}\n            {...this.props}\n            {/* and additional props calculated from Redux store */}\n            {...mapStateToProps(store.getState(), this.props)}\n            {...mapDispatchToProps(store.dispatch, this.props)}\n          />\n        )\n      }\n      \n      componentDidMount() {\n        // it remembers to subscribe to the store so it doesn't miss updates\n        this.unsubscribe = store.subscribe(this.handleChange.bind(this))\n      }\n      \n      componentWillUnmount() {\n        // and unsubscribe later\n        this.unsubscribe()\n      }\n    \n      handleChange() {\n        // and whenever the store state changes, it re-renders.\n        this.forceUpdate()\n      }\n    }\n  }\n}\n</code></pre>\n<p>如上就是<code>connect</code>一个简单版本的实现，<code>connect</code>是一个包装过的高阶组件的函数，在第一层接受一个<code>selector</code>函数，接收<code>redux</code>的<code>state</code>和传给组件的<code>props</code>， 然后将需要包装的组件传给返回后的函数，最后返回的组件中就可以从<code>props</code>上拿到<code>redux state</code>上的数据了，上面这个是一个简陋的<code>connect</code>实现，我们来看看<code>react redux</code>真正的实现。</p>\n<p>我们先来看看<code>connect</code>是如何解析我们传入的参数的，<code>connect</code>的<code>map*</code>传入的格式支持直接传入函数，也可以传入一个<code>obejct</code>，来看看<code>react-redux</code>是如何支持不同的输入的。</p>\n<pre><code class=\"language-javascript\">// createConnect with default args builds the 'official' connect behavior. Calling it with\n// different options opens up some testing and extensibility scenarios\nexport function createConnect({\n  connectHOC = connectAdvanced,\n  mapStateToPropsFactories = defaultMapStateToPropsFactories,\n  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,\n  mergePropsFactories = defaultMergePropsFactories,\n  selectorFactory = defaultSelectorFactory\n}{\n    ......\n}\n\nexport default createConnect()\n</code></pre>\n<p>如上，是<code>connect.js</code>文件暴露出来的<code>connect</code>接口，外面用的时候，是使用的<code>createConnect</code>的返回值。\n在这里<code>createConnect</code>使用了默认参数，分别是：</p>\n<ul>\n<li><code>connectAdvanced</code></li>\n<li><code>defaultMapStateToPropsFactories</code></li>\n<li><code>defaultMapDispatchToPropsFactories</code></li>\n<li>defaultMergePropsFactories</li>\n<li>defaultSelectorFactory</li>\n</ul>\n<p>我们这里先看和<code>props</code>相关的<code>defaultMapStateToPropsFactories</code>和<code>defaultMapDispatchToPropsFactories</code>。</p>\n<pre><code class=\"language-javascript\">const initMapStateToProps = match(\n      mapStateToProps,\n      mapStateToPropsFactories,\n      'mapStateToProps'\n    )\nconst initMapDispatchToProps = match(\n      mapDispatchToProps,\n      mapDispatchToPropsFactories,\n      'mapDispatchToProps'\n    )\n</code></pre>\n<p>当调用<code>connect</code>的时候，这里会调用<code>match</code>函数，来辨别出我们传入的<code>mapStateToProps</code>和<code>mapDispatchToProps</code>是函数还是<code>object</code>。</p>\n<pre><code class=\"language-javascript\">function match(arg, factories, name) {\n  for (let i = factories.length - 1; i >= 0; i--) {\n    const result = factories[i](arg)\n    if (result) return result\n  }\n\n  return (dispatch, options) => {\n    throw new Error(\n      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${\n        options.wrappedComponentName\n      }.`\n    )\n  }\n}\n</code></pre>\n<p>上面就是<code>match</code>函数的代码，这里会将我们传入的<code>map*</code>函数作为参数，传入给<code>mapDispatchToPropsFactories</code>这个工厂函数，我们来这个工厂函数的实现。</p>\n<pre><code class=\"language-javascript\">import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\n\nexport function whenMapStateToPropsIsFunction(mapStateToProps) {\n  return typeof mapStateToProps === 'function'\n    ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps')\n    : undefined\n}\n\nexport function whenMapStateToPropsIsMissing(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : undefined\n}\n\nexport default [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]\n</code></pre>\n<p>如上是<code>mapStateToPropsFactories</code>的实现，这里<code>export</code>出去的是一个<code>array</code>，分别是当<code>mapStateToProps</code>是函数和没有传入的时候，最后返回的是<code>wrapMapToPropsFunc</code>这个函数包装后的函数。</p>\n<pre><code class=\"language-javascript\">export function wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch,{ displayName }){\n    ......\n}\n</code></pre>\n<p>这里<code>wrapMapToPropsFuc</code>，返回值是一个<code>(dispatch, { displayName}) => {}</code>的接口，这里就是工厂函数生成的函数的接口，这个函数也是被<code>mapDispatchToProps</code>复用的，生成统一的接口函数。</p>\n<pre><code class=\"language-javascript\">import { bindActionCreators } from 'redux'\nimport { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps'\n\nexport function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {\n  return typeof mapDispatchToProps === 'function'\n    ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')\n    : undefined\n}\n\nexport function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {\n  return !mapDispatchToProps\n    ? wrapMapToPropsConstant(dispatch => ({ dispatch }))\n    : undefined\n}\n\nexport function whenMapDispatchToPropsIsObject(mapDispatchToProps) {\n  return mapDispatchToProps &#x26;&#x26; typeof mapDispatchToProps === 'object'\n    ? wrapMapToPropsConstant(dispatch =>\n        bindActionCreators(mapDispatchToProps, dispatch)\n      )\n    : undefined\n}\n\nexport default [\n  whenMapDispatchToPropsIsFunction,\n  whenMapDispatchToPropsIsMissing,\n  whenMapDispatchToPropsIsObject\n]\n</code></pre>\n<p>如上是<code>mapDispatchToProps</code>的代码，<code>mapDisptchToProps</code>支持函数、<code>Object</code>、或者不传任何参数，和<code>mapStateToProps</code>一样最后也是返回<code>(dispatch, { options }) => {}</code>。在将<code>map*</code>函数初始化好之后，后面就是调用一个高阶组件函数，用来接收我们想要从<code>redux</code>上获取数据的组件。</p>\n<pre><code class=\"language-javascript\">    return connectHOC(selectorFactory, {\n      // used in error messages\n      methodName: 'connect',\n\n      // used to compute Connect's displayName from the wrapped component's displayName.\n      getDisplayName: name => `Connect(${name})`,\n\n      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes\n      shouldHandleStateChanges: Boolean(mapStateToProps),\n\n      // passed through to selectorFactory\n      initMapStateToProps,\n      initMapDispatchToProps,\n      initMergeProps,\n      pure,\n      areStatesEqual,\n      areOwnPropsEqual,\n      areStatePropsEqual,\n      areMergedPropsEqual,\n\n      // any extra options args can override defaults of connect or connectAdvanced\n      ...extraOptions\n    })\n</code></pre>\n<p>上面的代码就是<code>connect(map1, map2)</code>的返回值，这里调用了<code>connectHOC(connectAdvanced)</code>，我们来看看<code>connectAdvanced</code>函数的代码：</p>\n<pre><code class=\"language-javascript\">export default function connectAdvanced(selectorFactory, {.../* options object*/}) {\n    ......\n    return return function wrapWithConnect(WrappedComponent) { ...}\n}\n</code></pre>\n<p>上面的代码是<code>connectAdvanced</code>函数的接口和返回值，这里接受<code>selectorFactory</code>和<code>options</code>设置，这里的<code>selectorFactory</code>函数就是将我们在上一步调用初始化好的<code>map*</code>函数由<code>(dispatch, { options }) => {}</code>的形式转换为<code>(stateOrDispatch, ownProps) => {}</code>的形式。</p>\n<pre><code class=\"language-javascript\">export default function finalPropsSelectorFactory(\n  dispatch,\n  { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }\n) {\n  const mapStateToProps = initMapStateToProps(dispatch, options)\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)\n  const mergeProps = initMergeProps(dispatch, options)\n\n  if (process.env.NODE_ENV !== 'production') {\n    verifySubselectors(\n      mapStateToProps,\n      mapDispatchToProps,\n      mergeProps,\n      options.displayName\n    )\n  }\n\n  const selectorFactory = options.pure\n    ? pureFinalPropsSelectorFactory\n    : impureFinalPropsSelectorFactory\n\n  return selectorFactory(\n    mapStateToProps,\n    mapDispatchToProps,\n    mergeProps,\n    dispatch,\n    options\n  )\n}\n</code></pre>\n<p>上面的代码就是<code>selectorFactory</code>函数的实现，这里首先调用了由<code>map</code>工厂函数生成的函数，返回的函数就是由<code>wrapMapToPropsFunc</code>返回的函数，这里我们来看看<code>wrapMapToPropsFunc</code>的实现：</p>\n<pre><code class=\"language-javascript\">export function wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, { displayName }) {\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps\n        ? proxy.mapToProps(stateOrDispatch, ownProps)\n        : proxy.mapToProps(stateOrDispatch)\n    }\n\n    // allow detectFactoryAndVerify to get ownProps\n    proxy.dependsOnOwnProps = true\n\n    proxy.mapToProps = function detectFactoryAndVerify(\n      stateOrDispatch,\n      ownProps\n    ) {\n      proxy.mapToProps = mapToProps\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps)\n      let props = proxy(stateOrDispatch, ownProps)\n\n      if (typeof props === 'function') {\n        proxy.mapToProps = props\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props)\n        props = proxy(stateOrDispatch, ownProps)\n      }\n\n      if (process.env.NODE_ENV !== 'production')\n        verifyPlainObject(props, displayName, methodName)\n\n      return props\n    }\n\n    return proxy\n  }\n}\n</code></pre>\n<p>这里的<code>wrapMapToPropsFunc</code>最终返回的是一个<code>proxy</code>函数，这个函数的接口是<code>(dispatchOrState, ownProps) => {}</code>，这也我们的<code>map*</code>函数的接口相同，这里<code>proxy</code>函数主要是处理在第一次运行的时候，如果我们提供的<code>map*</code>函数的返回值是<code>map</code>函数这种情况，另外就是检测最后我们提供的<code>map*</code>函数的返回值是一个<code>plain object</code>的情况。</p>\n<p>在拿到真正的<code>map*</code>函数后，会判断传入的<code>options</code>中<code>pure</code>的值来决定使用哪一个<code>SelectorFactory</code>函数，默认情况下会使用<code>pureFinalPropsSelectorFactory</code>，如果<code>pure</code>为<code>false</code>的话会使用<code>impureFinalPropsSelectorFactory</code>，前一个函数缓存了前一次的<code>state</code>，<code>ownProps</code>，<code>stateProps</code>，<code>dispatchProps</code>，<code>mergedProps</code>，在第一次调用<code>connect</code>的时候，会设置好缓存，在后续的调用中会比较缓存，如果缓存的引用没变，就不会调用<code>map*</code>函数生成新的<code>props</code>。具体的实现代码如下：</p>\n<pre><code class=\"language-javascript\">export function pureFinalPropsSelectorFactory(\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps,\n  dispatch,\n  { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }\n) {\n  let hasRunAtLeastOnce = false\n  let state\n  let ownProps\n  let stateProps\n  let dispatchProps\n  let mergedProps\n\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState\n    ownProps = firstOwnProps\n    stateProps = mapStateToProps(state, ownProps)\n    dispatchProps = mapDispatchToProps(dispatch, ownProps)\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    hasRunAtLeastOnce = true\n    return mergedProps\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps)\n\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    return mergedProps\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps)\n      stateProps = mapStateToProps(state, ownProps)\n\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps)\n\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n    return mergedProps\n  }\n\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps)\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)\n    stateProps = nextStateProps\n\n    if (statePropsChanged)\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)\n\n    return mergedProps\n  }\n\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)\n    const stateChanged = !areStatesEqual(nextState, state)\n    state = nextState\n    ownProps = nextOwnProps\n\n    if (propsChanged &#x26;&#x26; stateChanged) return handleNewPropsAndNewState()\n    if (propsChanged) return handleNewProps()\n    if (stateChanged) return handleNewState()\n    return mergedProps\n  }\n\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce\n      ? handleSubsequentCalls(nextState, nextOwnProps)\n      : handleFirstCall(nextState, nextOwnProps)\n  }\n}\n</code></pre>\n<p>如上是<code>pureFinalPropsSelectorFactory</code>的实现，这里在第一次调用的时候产生一份缓存，后续的调用会检查缓存。</p>\n<p>上面的一连串过程就是<code>props</code>如何产生，以及<code>props</code>的刷新过程。简要的来说，这里的几个不同的<code>factory</code>函数，主要的工作是统一接口，校验传进来的参数，函数接口的转换形式如下：</p>\n<pre><code class=\"language-javascript\">(dispatch, options) => (mapOrDispatch, ownProps) => finalProps\n</code></pre>\n<p>上面就是这几个<code>factory</code>函数的主要工作。</p>\n<p>我们继续来看<code>connect</code>后续的代码的主要工作是返回一个高阶组件来包装我们的组件：</p>\n<pre><code class=\"language-javascript\">export default function connectAdvanced(selectoryFactory, {\n    ...\n    /*options object*/\n}) {\n    return withConnect(WrappedComponent) {\n        ......\n    }\n}\n</code></pre>\n<p>这里对这个高阶组件做了几个小的处理，一是对于<code>forwardRef</code>的处理，而是对<code>Context</code>的处理。</p>\n<pre><code class=\"language-javascript\">    if (forwardRef) {\n      const forwarded = React.forwardRef(function forwardConnectRef(\n        props,\n        ref\n      ) {\n        return &#x3C;Connect wrapperProps={props} forwardedRef={ref} />\n      })\n\n      forwarded.displayName = displayName\n      forwarded.WrappedComponent = WrappedComponent\n      return hoistStatics(forwarded, WrappedComponent)\n    }\n</code></pre>\n<p>如上，如果<code>forwardRef</code>为<code>true</code>的时候，这个时候，会讲<code>ref</code>挂到<code>connect</code>包的底层组件上；另外就是对<code>context</code>的处理了</p>\n<pre><code class=\"language-javascript\">render() {\n        const ContextToUse =\n          this.props.context &#x26;&#x26;\n          this.props.context.Consumer &#x26;&#x26;\n          isContextConsumer(&#x3C;this.props.context.Consumer />)\n            ? this.props.context\n            : Context\n\n        return (\n          &#x3C;ContextToUse.Consumer>\n            {this.indirectRenderWrappedComponent}\n          &#x3C;/ContextToUse.Consumer>\n        )\n      }\n</code></pre>\n<p><code>connect</code>的第三个参数支持注入我们自己的<code>context</code>，如上的代码，如果我们在<code>mergeProps</code>中注入了我们自己的<code>context</code>，会优先使用我们自己的<code>context</code>，否则就使用<code>Provider</code>上提供的<code>context</code>。在之前讲的到，<code>selectorFactory</code>会讲<code>wrapMapToProps</code>包装后的函数<code>(dispatch, options) => {}</code> 转换为<code>(stateOrDispatch, ownProps) => {}</code>。在代码里的体现如下：</p>\n<pre><code class=\"language-javascript\">render() {\n        const ContextToUse =\n          this.props.context &#x26;&#x26;\n          this.props.context.Consumer &#x26;&#x26;\n          isContextConsumer(&#x3C;this.props.context.Consumer />)\n            ? this.props.context\n            : Context\n\n        return (\n          &#x3C;ContextToUse.Consumer>\n            {this.indirectRenderWrappedComponent}\n          &#x3C;/ContextToUse.Consumer>\n        )\n      } \n</code></pre>\n<p>在<code>connect</code>的<code>render</code>方法中，调用了<code>this.indirectRenderWrappedComponent</code>，这个方法实际上就是<code>makeDerivedPropsSelector</code>返回的函数，我们来看看这个方法的代码：</p>\n<pre><code class=\"language-javascript\"> function makeDerivedPropsSelector() {\n      let lastProps\n      let lastState\n      let lastDerivedProps\n      let lastStore\n      let lastSelectorFactoryOptions\n      let sourceSelector\n\n      return function selectDerivedProps(\n        state,\n        props,\n        store,\n        selectorFactoryOptions\n      ) {\n        if (pure &#x26;&#x26; lastProps === props &#x26;&#x26; lastState === state) {\n          return lastDerivedProps\n        }\n\n        if (\n          store !== lastStore ||\n          lastSelectorFactoryOptions !== selectorFactoryOptions\n        ) {\n          lastStore = store\n          lastSelectorFactoryOptions = selectorFactoryOptions\n          sourceSelector = selectorFactory(\n            store.dispatch,\n            selectorFactoryOptions\n          )\n        }\n\n        lastProps = props\n        lastState = state\n\n        const nextProps = sourceSelector(state, props)\n\n        lastDerivedProps = nextProps\n        return lastDerivedProps\n      }\n    }\n</code></pre>\n<p>可以看到在第一次运行，更换<code>store</code>或更换<code>selectorFactoryOptions</code>\u0010的时候，会重新获取<code>store</code>和<code>selectorFactoryOptions</code>，这块函数就是每次<code>context</code>刷新或者<code>props change</code>的时候，调用当前的<code>map*</code>函数，生成新的<code>props</code>或者是使用旧的<code>props</code>。最后调用<code>makeChildElementSelector</code>将计算好的props，要渲染的组件，以及要转发的<code>ref</code>传进去，可以看到这里的刷新也是有一层缓存的，如果传入的这些东西还是上一次的话，这里还是会返回上一次渲染的组件。</p>\n<pre><code class=\"language-javascript\">   function makeChildElementSelector() {\n      let lastChildProps, lastForwardRef, lastChildElement, lastComponent\n\n      return function selectChildElement(\n        WrappedComponent,\n        childProps,\n        forwardRef\n      ) {\n        if (\n          childProps !== lastChildProps ||\n          forwardRef !== lastForwardRef ||\n          lastComponent !== WrappedComponent\n        ) {\n          lastChildProps = childProps\n          lastForwardRef = forwardRef\n          lastComponent = WrappedComponent\n          lastChildElement = (\n            &#x3C;WrappedComponent {...childProps} ref={forwardRef} />\n          )\n        }\n\n        return lastChildElement\n      }\n    }\n</code></pre>\n<p>在没有转发<code>ref</code>的情况下，<code>connect</code>组件会返回：</p>\n<pre><code class=\"language-javascript\">   return hoistStatics(Connect, WrappedComponent)\n</code></pre>\n<p>这里的<code>hoistStatics</code>函数是为了将<code>WrapperComponent</code>上的静态属性复制到<code>Connect</code>的组件上；原因在于，如果原始的组件上有一个静态方法，在<code>connect</code>之后的组件暴露出去用的时候，这个组件实际上是访问不到的，所以要把一些静态属性拷到高阶组件上去。</p>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"React-Redux源码剖析","date":"January 26, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-1-26-ReactRedux源码解读/","previous":{"fields":{"slug":"/2019-1-19-HowReactReduxWorks/"},"frontmatter":{"title":"如何使用React—Redux","category":"Tech"}},"next":{"fields":{"slug":"/2019-2-06-Javascript模块化/"},"frontmatter":{"title":"Javascript模块化","category":"Tech"}}}}