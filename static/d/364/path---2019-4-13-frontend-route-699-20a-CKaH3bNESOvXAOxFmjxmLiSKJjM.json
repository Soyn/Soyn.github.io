{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"764ab1c0-3092-5baf-b764-7005b5d16116","excerpt":"什么是路由？ 路由最一开始是在后端中出现的，我们在访问某些网站的时候经常会见到类似于这样的 url :\n http://www.xxx.com/xxx.php  或者  http://www.xxx.com/xxx.html ，这就是 SSR （Server Side Render）服务端渲染，通过后端直接渲染前端页面。这里客户端会发向服务端发请求，服务端解析 url ，根据 url 将需要的资源返回给前端，路由其实就是前端和服务端的一种交互方式，相当于服务端针对于 不同url 的 switch case ，每一类 case…","html":"<h2>什么是路由？</h2>\n<p>路由最一开始是在后端中出现的，我们在访问某些网站的时候经常会见到类似于这样的<code>url</code>:\n<code>http://www.xxx.com/xxx.php</code> 或者 <code>http://www.xxx.com/xxx.html</code>，这就是<code>SSR</code>（Server Side Render）服务端渲染，通过后端直接渲染前端页面。这里客户端会发向服务端发请求，服务端解析<code>url</code>，根据<code>url</code>将需要的资源返回给前端，路由其实就是前端和服务端的一种交互方式，相当于服务端针对于<code>不同url</code>的<code>switch case</code>，每一类<code>case</code>对应一个<code>controller</code>。</p>\n<h2>前端路由</h2>\n<p>上面介绍了传统意义上的路由，用户在页面上点击的时候触发页面请求，服务端将对应的页面返回回来，这样存在一个问题是，整个页面会重新加载，会产生无意义的白屏页面，用户体验不好。在用户点击访问网站或者<code>Web App</code>上的另一个页面的时候，这个时候我们可能仅仅需要的是更新部分视图就可以了，而没有必要去重新加载整个页面，避免无意义的白屏；这个时候前端路由就出现了，页面的跳转和渲染放在前端，后端提供<code>API</code>获取数据即可。</p>\n<h2>前端路由的实现原理</h2>\n<p>对于前端路由有两种实现方式，一种是通过<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event\"><code>hashchanged</code></a>；另一种是使用<code>HTML5</code>提供的<code>history api</code>来做前端路由的处理。\n对于<code>hasnchange</code>的实现方式，我们需要监听<code>hashchange</code>事件，在浏览器的<code>url</code>中改变<code>hash</code>不会导致页面发请求，我们在<code>hashchange</code>的事件回调中处理页面中<code>DOM</code>的刷新。\n<img src=\"./images/19-4-13-03.jpg\" alt=\"hashchange\">\n在<code>html5</code>推出<code>pushstate</code>和<code>replacestate</code>之后，就可以通过这两个<code>api</code>来改变<code>url</code>并且不发请求，而且相比于使用<code>hash</code>，页面的<code>url</code>更加美观，但是通过<code>pushstate</code>方式改变了<code>url</code>，如果这个时候刷新了页面，服务端会收到请求，这个时候后端没有对应的<code>controller</code>来处理，所以在<code>pushstate</code>的实现方式下，后端最好对于没有路由的<code>url</code>直接返回到主页面。</p>\n<h2>如何实现一个简单的前端路由</h2>\n<p>这里我们来尝试实现一个简单的前端路由，主要的思想就是侦测<code>url</code>的变化，解析<code>url</code>，调用<code>handler</code>，整个路由是一个单例。</p>\n<pre><code class=\"language-javascript\">const Route = {\n    routes: [],\n    config: function(options) {\n        this.root = options.root || '/';\n        if (options.mode === 'history' &#x26;&#x26; typeof history.pushState === 'function') {\n            this.mode = 'history';\n        } else {\n            this.mode = 'hash';\n        }\n        return this;\n    }\n}\n</code></pre>\n<p>基于浏览器的两种实现方式，我们实现路由的时候，提供<code>mode</code>的设置，默认是'hash'的实现，这里我们配置了根路径，这里主要是处理在<code>pushstate</code>的实现中，<code>pushstate</code>导致无法获取到<code>url</code>改变的部分的问题：\n<img src=\"./images/19-4-13-01.png\">\n<img src=\"./images/19-4-13-02.png\">\n如上图，我们原本的页面在<code>https://github.com</code>下，在第一次<code>pushstate</code>的时候，没有问题，但是在第二次<code>pushstate</code>的时候，和我们期待的<code>url</code>并不符合，这会导致的问题是，我们在解析<code>url change</code>的部分的时候，会得到错误的结果，所以这里我们指定好根目录，在解析的时候将<code>url</code>中根路径剔除掉。</p>\n<pre><code class=\"language-javascript\">  getFragement: function () {\n    let fragement = '';\n    if (this.mode === 'history') {\n      fragement = location.pathname + location.search;\n      fragement = this.clearSlash(fragement);\n      fragement = fragement.replace('/\\?(.*)$/', '');  // replace the query string\n      fragement = this.root !== '/' ? fragement.replace(this.root, '') : fragement;\n    } else {\n      fragement = location.hash.slice(1);\n    }\n    return fragement;\n  }\n</code></pre>\n<p>上面的代码就是去解析出'url'改变的部分；在<code>pushstate</code>的实现中，存在一个问题是，我们在<code>url</code>跳转的时候，是调用<code>pushstate</code>来改变<code>url</code>，但是这并不能触发<code>popstate</code>的事件，所以这里我们需要去<code>listen url</code>的变化：</p>\n<pre><code class=\"language-javascript\">  startTimer: function(fn, ms) {\n    const self = this;\n    const internalFn = function () {\n      fn();\n      self.timer = setTimeout(internalFn, ms);\n    }\n    this.timer = setTimeout(internalFn, ms);\n  },\n  listen: function () {\n    let current = this.getFragement();\n    let self = this;\n    const fn = function() {\n      if (current !== self.getFragement()) {\n        current = self.getFragement();\n        self.check(current);\n      }\n    };\n    this.startTimer(fn, 50);\n    return this;\n  },\n</code></pre>\n<p>完整的代码实现请查看： <a href=\"https://github.com/Soyn/FERoute\">FERoute</a></p>\n<h2>Refrence</h2>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/53064386\">https://www.zhihu.com/question/53064386</a></li>\n<li><a href=\"https://juejin.im/post/5b40c1ede51d4518f140f84b\">https://juejin.im/post/5b40c1ede51d4518f140f84b</a></li>\n<li><a href=\"https://www.zhihu.com/question/63586494\">前端管理路由相比后端有什么优势？ - 知乎</a></li>\n<li><a href=\"http://krasimirtsonev.com/blog/article/deep-dive-into-client-side-routing-navigo-pushstate-hash\">http://krasimirtsonev.com/blog/article/deep-dive-into-client-side-routing-navigo-pushstate-hash</a></li>\n<li><a href=\"https://github.com/SME-FE/sme-router\">GitHub - SME-FE/sme-router: A lightweight router lib that implement with express route style</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API\">https://developer.mozilla.org/en-US/docs/Web/API/History_API</a></li>\n<li><a href=\"https://github.com/krasimir/navigo\">GitHub - krasimir/navigo: A simple vanilla JavaScript router with a fallback for older browsers</a>\n<a href=\"https://medium.com/@wilbo/server-side-vs-client-side-routing-71d710e9227f\">Server-side vs Client-side Routing – Wilbert Schepenaar – Medium</a></li>\n</ul>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"前端路由","date":"April 13, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-4-13-frontend-route/","previous":{"fields":{"slug":"/2019-3-23-StateManager/"},"frontmatter":{"title":"实现一个前端状态管理库","category":"Tech"}},"next":{"fields":{"slug":"/2019-4-20-Promise/"},"frontmatter":{"title":"Promise初探","category":"Tech"}}}}