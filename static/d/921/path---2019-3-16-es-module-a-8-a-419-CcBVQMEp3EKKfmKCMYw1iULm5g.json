{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"48029087-838b-52df-881a-6a275e5d08ea","excerpt":"在ES6之前， Javascript 并没有官方标准的模块化方案，在社区中就出现了 Common.js 和 AMD 这两种方案，前者主要用于服务端，后者用在浏览器端，为了统一写法，又出现了 UMD 的标准，在 ES6 中， Javascript 终于有了官方标准的模块化方案，这篇博客我们就来看看 ES6 的模块化方案。 Overview 定义和使用模块 如上，是 ES6 中 Module 的用法，这里有两个保留字 import 和 export ，从上面的代码中，我们可以发现，对于不同的 export 方式，对应的 import…","html":"<p>在ES6之前，<code>Javascript</code>并没有官方标准的模块化方案，在社区中就出现了<code>Common.js</code>和<code>AMD</code>这两种方案，前者主要用于服务端，后者用在浏览器端，为了统一写法，又出现了<code>UMD</code>的标准，在<code>ES6</code>中，<code>Javascript</code>终于有了官方标准的模块化方案，这篇博客我们就来看看<code>ES6</code>的模块化方案。</p>\n<h1>Overview</h1>\n<h2>定义和使用模块</h2>\n<pre><code class=\"language-javascript\">// ------lib.js-----\nexport function foo() {\n    console.log('foo in lib.js');\n}\nexport default function bar() { \n    console.log('bar in lib.js')\n}\n// ------main.js-----\nimport { foo } from './lib.js';\nimport bar from './lib.js';\n</code></pre>\n<p>如上，是<code>ES6</code>中<code>Module</code>的用法，这里有两个保留字<code>import</code>和<code>export</code>，从上面的代码中，我们可以发现，对于不同的<code>export</code>方式，对应的<code>import</code>的方式也不一样。</p>\n<h2>Name Export</h2>\n<pre><code class=\"language-javascript\">// ------lib.js-----\nlet a = 1;\nexport foo() {}\nexport bar() {}\nexport a;\n</code></pre>\n<p>如上，就是<code>name export</code>的写法，每一个函数或者变量，直接被<code>export</code>，这种每写一个函数或者变量就<code>export</code>的方式也叫做<code>inline export</code>，如果在一个<code>Module</code>中有很多需要<code>export</code>的东西，这种写法就有些累赘了，这时候可以写成这样：</p>\n<pre><code class=\"language-javascript\">// ------lib.js------\nlet a = 1;\nfunction foo() {}\nfunction bar() {}\nexport {\n    foo,\n    bar,\n    a\n}\n</code></pre>\n<p>在<code>ES6 Module</code>中，有<code>local name</code>和<code>export name</code>的概念，顾名思义<code>local name</code>就是在<code>Module</code>中的名字，<code>export name</code>就是模块暴露给外界的名字。</p>\n<pre><code class=\"language-javascript\">// ------lib.js------\nlet a = 1;\nfunction foo() {} // {A}\nfunction bar() {} \nexport {\n    foo as bar,  // {B}\n    bar as foo,\n    a as b,\n}\n</code></pre>\n<p>在上面的代码中，<code>{A}</code>行的<code>foo</code>是<code>local name</code>，在<code>{B}</code>行的<code>bar</code>是<code>export name</code>，同样的我们在<code>import</code>的时候也可以使用别名。</p>\n<pre><code class=\"language-javascript\">// ------lib.js------\nexport function foo() {}\n// ------main.js------\nimport { foo as bar } from './lib.js';\nbar();\n</code></pre>\n<h2>Default Export</h2>\n<pre><code class=\"language-javascript\">// ------lib.js------\nexport default foo() {}\n// ------main.js------\nimport foo from 'lib.js';\nfoo();\n</code></pre>\n<p>如上，我们<code>import</code>了一个<code>default</code>的<code>export</code>，<code>default export</code>和<code>name export</code>在<code>import</code>的时候，<code>name export</code>需要加大括号，而<code>default export</code>则不需要。</p>\n<h2>转发export</h2>\n<pre><code class=\"language-javascript\">// ------lib.js------\nlet a = 1;\nfunction foo() {\n  console.log('foo in lib.js');\n}\n\nfunction bar() {\n  console.log('bar in lib.js')\n}\n\nexport {\n  foo,\n  bar,\n  a,\n}\n// ------middleLib.js------\nexport { foo as bar, bar as foo } from './lib';\n// ------main.js------\nimport { foo, bar } from './middleLib';\nfoo();\nbar();\n</code></pre>\n<p>如上我们将模块<code>lib.js</code>中暴露的<code>export</code>通过另一个模块暴露出去了，这种常见的用法是，在封装好一个大的模块后，这个大的模块只需要向外界暴露部分小模块的<code>API</code>：</p>\n<pre><code class=\"language-javascript\">- module\n  -- a.js\n  -- b.js\n  -- index.js\n</code></pre>\n<p>如上，在<code>module</code>这个<code>folder</code>下我们有<code>a.js, b.js, index.js</code>，<code>a.js和b.js</code>是一些功能的实现，我们将<code>a.js, b.js</code>中需要向外界暴露的<code>API</code>通过<code>index.js</code>转发。</p>\n<h1>ES6 Module Under Hood</h1>\n<p><code>ES6</code>给我们提供了很简洁的语法去使用模块，但是<code>ES Module</code>简洁的外表下，背后的细节仍然值得我们注意。</p>\n<h2>ES Module是静态的</h2>\n<p>如何理解<code>ES Module</code>是静态的这句话呢？意思就是，<code>ES Module</code>不同于<code>Common.js</code>这种模块化方案，只有在运行时才可以确定依赖的模块，在源码中看到的依赖关系就是运行时的依赖。</p>\n<pre><code class=\"language-javascript\">//------commonJSModule.js------\nfunction foo() {}\nfunction bar() {}\n\nmodule.exports = {\n foo,\n bar,\n}\n//------main.js------\nif (something) {\n    let foo = require('./commonJSModule.js').foo;\n    foo();\n} else {\n    let foo = require('./commonJSModule.js').bar;\n    bar();\n}\n</code></pre>\n<p>如上，在<code>CommonJS</code>中这中动态的在运行时决定依赖的方式在<code>ES Module</code>中是行不通的（但是有提案在做运行时的<code>loader</code> --> <a href=\"https://github.com/whatwg/loader/%EF%BC%89%E3%80%82\">https://github.com/whatwg/loader/）。</a></p>\n<h2>ES Module的变量提升</h2>\n<pre><code class=\"language-javascript\">// ------lib.js------\nlet a = 1;\nfunction foo() {\n  console.log('foo in lib.js');\n}\n\nfunction bar() {\n  console.log('bar in lib.js')\n}\n\nexport {\n  foo,\n  bar,\n  a,\n}\n// ------main.js------\nfoo();\nbar();\nimport { foo, bar } from './lib';\n</code></pre>\n<p>如上，我们可以先调用<code>export</code>的函数，在调用之后再<code>import</code>，这个在编译的时候会将<code>import</code>提升到顶层，但是在实际开发的过程中，虽然可以这样，但是这并不是好的代码风格。</p>\n<h2>ES Module是只读的</h2>\n<pre><code class=\"language-javascript\">// ------commonJSModule.js------\nfunction foo(){}\nlet a = 0;\nmodule.exports = {\n    foo,\n    a,\n}\n// ------main.js------\nlet a = require('./lib.js').a;\n++a; // 1\nconsole.log(require('./lib.js').a) // 0\n</code></pre>\n<p>上面的代码在<code>CommonJS</code>下，我们可以修改<code>require</code>的东西，因为在<code>commonJS</code>中是拷贝一份，但是在<code>ES Module</code>中，我们无法修改<code>import</code>的东西，<code>import</code>的模块在行为上类似于<code>const</code>变量和<code>frozen object</code></p>\n<pre><code class=\"language-javascript\">// ------lib.js------\nlet a = 1;\nfunction foo() {\n  console.log('foo in lib.js');\n}\n\nfunction bar() {\n  console.log('bar in lib.js')\n}\n\nexport {\n  foo,\n  bar,\n  a,\n}\n// ------main.js------\nimport { foo, bar, a } from './lib';\nfoo();\nbar();\nfoo.a = 1; // works {A}\n++a; // error {B}\n</code></pre>\n<h2>ES Module静态结构的设计带来的益处</h2>\n<p><code>ES Module</code>的静态结构的设计特点，让代码在编译的时候就能确定依赖关系，不同于运行时，只有代码跑起来的时候很多东西才能确定，就好比，你计划完成一项复杂的项目，静态的结构能保证你在做之前，你确定的事是不会变的，而不是只要等到在项目进行中去确定，面对可预测的问题，我们是好解决的。</p>\n<ul>\n<li>有助于在代码打包的时候做 <code>dead code elimination</code>，减小<code>bundle</code>文件的大小（<code>RollUp</code>基于<code>ES Module</code>实现了<code>tree shaking</code>）</li>\n<li>静态的结构有助于<code>lint</code>工具的检测</li>\n<li>为<code>javascript</code>支持宏做准备（宏操作需要静态的结构 --> <a href=\"https://www.sweetjs.org/%EF%BC%89\">https://www.sweetjs.org/）</a></li>\n</ul>\n<h1>Reference</h1>\n<ul>\n<li><a href=\"http://exploringjs.com/es6/ch_modules.html\">ES6 Module</a></li>\n<li><a href=\"https://stackoverflow.com/questions/41706953/are-the-new-ecmascript-6-import-and-export-asynchronous\">Are the new ECMAScript 6 import and export asynchronous?</a></li>\n</ul>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"ES6 Module","date":"March 16, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-3-16-ESModule/","previous":{"fields":{"slug":"/2019-3-2-AsyncAndDeferInScript/"},"frontmatter":{"title":"script在HTML中的加载","category":"Tech"}},"next":{"fields":{"slug":"/2019-3-23-StateManager/"},"frontmatter":{"title":"实现一个前端状态管理库","category":"Tech"}}}}