{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"50691342-3011-5c91-b969-243902e0b80a","excerpt":"Problem 我们先来看一个 Demo （切到 0.5x）: 在上面的 Demo 中，在 touchStart 的事件的 callback 中跑了一段 JS 的循环，打开 Chrome 的 devtools ，切换到移动端的模式，在页面上滑动的时候，可以明显感觉到左边盒子的滚动有明显的延迟和卡顿，而右边的盒子滚动起来却很顺滑；这两个盒子的 touchStart 事件的 callback 跑的循环是一样的，差异在于右边盒子将 passive 置为了 true 。 Overview…","html":"<h1>Problem</h1>\n<p>我们先来看一个<code>Demo</code>（切到 0.5x）:</p>\n<p><iframe src=\"https://codepen.io/alnord/embed/preview/bGdjywK\" style=\"width:100%; height:300px;\"></iframe></p>\n<p>在上面的 Demo 中，在<code>touchStart</code>的事件的<code>callback</code>中跑了一段<code>JS</code>的循环，打开<code>Chrome</code>的<code>devtools</code>，切换到移动端的模式，在页面上滑动的时候，可以明显感觉到左边盒子的滚动有明显的延迟和卡顿，而右边的盒子滚动起来却很顺滑；这两个盒子的<code>touchStart</code>事件的<code>callback</code>跑的循环是一样的，差异在于右边盒子将<code>passive</code>置为了<code>true</code>。</p>\n<pre><code>const test = document.getElementById('test')\nconst test1 = document.getElementById('test1')\ntest.addEventListener('touchstart', e => {\n  for (let i = 0; i &#x3C; 10000000; i += 1) {\n    for (let j = 0; j &#x3C; 100; j += 1) {}\n  }\n})\n\ntest1.addEventListener(\n  'touchstart',\n  e => {\n    let sum = 0\n    for (let i = 0; i &#x3C; 10000000; i += 1) {\n      for (let j = 0; j &#x3C; 100; j += 1) {}\n    }\n  },\n  { passive: true }\n)\n</code></pre>\n<h1>Overview</h1>\n<p>页面的平滑滚动对于用户体验来说是很重要的，特别是移动端，如果开发人员在<code>touchstart</code>或者<code>touchmove</code>中执行了涉及<code>JS</code>的代码，会影响页面的滚动，原因在于页面的滚动在浏览器中是由另一个线程负责的，在页面滚动的过程中，如果触发了<code>JS</code>的执行，这个线程会等待主线程执行完<code>JS</code>再触发滚动（因为在事件回调中可能执行<code>preventDefault</code>，会将滚动行为停止掉），所以，类似于上面<code>demo</code>的代码，左边盒子的<code>touchstart</code>的<code>callback</code>执行了耗时的<code>JS</code>计算，页面的滚动在等待<code>JS</code>的执行完成，用户体验上就会感到卡顿。</p>\n<h1>Solution</h1>\n<p>在 DOM 的事件绑定中，我们使用<code>addEventListenr</code>这个函数签名的第二个参数是一个<code>obj</code>，我们常用到的就是<code>{capture: true}</code>，用于在事件的捕获阶段（从文档的顶层到触发的 dom）绑定事件处理函数，这里还存在一个参数<code>{passive: true}</code>，将这个参数置为<code>true</code>之后，相当于通知浏览器，我这个回调函数不会执行<code>preventDefault</code>，对于上面我们<code>demo</code>中看到的滚动卡顿的问题来说，就相当于告诉控制滚动的线程，你继续滚动，我不会打断正常的滚动，所以就产生了<code>demo</code>中的差异。</p>","frontmatter":{"title":"使用Passive event保证平滑滚动","date":"March 21, 2020"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/tech/平滑滚动/","previous":{"fields":{"slug":"/2019-6-15-mvvm/"},"frontmatter":{"title":"双向绑定","category":"Tech"}},"next":null}}