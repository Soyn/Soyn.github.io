{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"b46b167e-e558-5b27-824a-187fcb0cddbe","excerpt":"在构建基于 Redux 的 React 应用的时候，我们往往需要使用 React-Redux 做数据绑定，当 Redux 中的数据刷新的时候，通知所有用到数据的组建刷新， React-Redux 提供了对 React 组件的订阅发布的能力。 我们为什么需要React-Redux 如果你熟悉 Redux 的话，我们知道在 Redux 中我们会维护一个全局的 store ， store 中存储了当前 App 中的数据，如果组件需要使用 store 中的数据，有两种办法，第一种是一层一层将 store 传下去，组件从 props 上去取 store…","html":"<p>在构建基于<code>Redux</code>的<code>React</code>应用的时候，我们往往需要使用<code>React-Redux</code>做数据绑定，当<code>Redux</code>中的数据刷新的时候，通知所有用到数据的组建刷新，<code>React-Redux</code>提供了对<code>React</code>组件的订阅发布的能力。</p>\n<h2>我们为什么需要React-Redux</h2>\n<p>如果你熟悉<code>Redux</code>的话，我们知道在<code>Redux</code>中我们会维护一个全局的<code>store</code>，<code>store</code>中存储了当前<code>App</code>中的数据，如果组件需要使用<code>store</code>中的数据，有两种办法，第一种是一层一层将<code>store</code>传下去，组件从<code>props</code>上去取<code>store</code>，然后取自己要用到的数据，很显然，这不是一个好的办法，如果存在一个嵌套很深的组件，那么<code>store</code>会从最顶层传到最下面，这对于代码的维护和可读性并不是很友好；第二种办法就是使用<code>React</code>提供的<code>context</code>，在要使用全局状态的时候，从<code>context</code>上去取，但是在<code>React 16.4.0</code>之前，<code>React</code>官方是不推荐使用<code>context</code>的，原因在于，当<code>context</code>中的值刷新的时候，是从上到下刷新的，如果中间有组件的<code>shouldComponentUpdate</code>返回了<code>false</code>，这个组件下面的组件就收不到更新后的值；而<code>React-Redux</code>实现了订阅发布的模式，保证使用了<code>store</code>的组件在数据更新的时候可以得到通知。</p>\n<p>在<code>React 16.4.0</code>之后官方将<code>createContext</code>暴露出来了，以上的问题不会出现，但是是不是意味着，可以用<code>context</code>来替代<code>redux</code>呢？理论上是可以的，但是并不推荐这样做，因为在<code>redux</code>的发展中，其生态系统是非常繁荣的，用<code>Redux</code>能避免重复造轮子的窘境。</p>\n<h2>React Redux给我们提供了哪些能力？</h2>\n<ul>\n<li>Container 组件和Presentational组件</li>\n</ul>\n<p><code>React</code>背后的思想是<code>UI组件</code>是一个函数，一个大的<code>Web App</code>就是一个由不同函数组成的大的函数；在处理这些组件时，我们遵循这样一个原则，根据职责将组件分为<code>container组件</code>和<code>presentational</code>组件，前者负责提供数据，后者接受数据，只负责展示；对于后者是对<code>redux</code>无感的，只负责从<code>props</code>上取数据，然后渲染。</p>\n<p><code>react-redux</code>的<code>connect</code>函数就提供了生成一个<code>container</code>组件负责和<code>store</code>进行交互，我们自己的组件就只用负责渲染就可以，数据的交互不用操心；<code>connect</code>将数据的来源抽象出来，使得我们的组件复用性更好。</p>\n<ul>\n<li>React-Redux的性能优化</li>\n</ul>\n<p>虽然<code>React</code>在数据更新的时候有着很好的性能，每次<code>React</code>刷新的时候是从父组件渲染到叶子组件，这里带来的问题就是，在子组件中数据没有发生变化，但是却重复渲染了，这种问题积少成多会导致性能问题，<code>react redux</code>在其内部提供了对应的性能优化，当组件的数据没有发生变化的时候，这个组件并不会重新渲染。</p>\n<h2>如何使用React Redux</h2>\n<p><code>react-redux</code>的核心<code>API</code>就三个，经常使用到的就两个，分别是：\n- <code>connect</code>\n- <code>Provider</code>\n- <code>ConnectAdvanced</code></p>\n<p>这里先来说说<code>Provider</code>的用法，简单来说就是<code>Provider</code>是一个容器组件，在你需要使用<code>react redux</code>管理你的<code>redux store</code>的时候，将你的<code>App</code>用<code>Provider</code>包起来，这样<code>Provider</code>下的所有组件都可以通过<code>connect</code>来获取<code>store</code>上存储的数据了。</p>\n<pre><code class=\"language-javascript\">import React, { Component } from 'react';\nimport { render } from 'react-dom';\nimport { Provider } from 'react-redux';\nimport Counter from './demos/reactReduxDemo/counter';\nimport { counterStore } from './demos/reactReduxDemo/configStore';\n\nclass App extends Component {\n  render() {\n    return(\n      &#x3C;Provider store={counterStore}>  // 将store注入到Provider中\n        &#x3C;Counter />\n      &#x3C;/Provider>\n    );\n  }\n}\nrender(&#x3C;App />, document.getElementById('root'));\n</code></pre>\n<p>如上，我们将<code>store</code>注入到组件中，当数据发生变化的时候，会通知<code>Provider</code>下的所有订阅了<code>store</code>的组件更新。</p>\n<p>在我们将<code>store</code>注入之后，其下的组件如果需要使用<code>store</code>中的数据，就需要使用<code>connect</code>这个<code>API</code>。\n<code>connect</code>其实就是一个高阶组件（传入一个组件，返回一个组件），这里<code>connect</code>的接口参数如下：</p>\n<pre><code class=\"language-javascript\">    connect(mapStateToProps, mapDispatchToProps, mergeProps, options)\n</code></pre>\n<p>这里的<code>mapStateToProps</code>主要是用来从<code>store</code>中获取数据的函数，这里的函数接口如下：</p>\n<pre><code class=\"language-javascript\">    const mapStateToProps = (state, ownProps) => { ... }\n</code></pre>\n<p>如上这里的<code>state</code>就是<code>store</code>，在<code>mapStateProps</code>中我们可以拿到整个应用的数据，在<code>mapStateToProps</code>中可以拿到我们需要的数据，另外一个参数<code>ownProps</code>是父组件传给子组件的<code>props</code>。\n另外一个函数<code>mapDispatchToProps</code>，这里的函数的参数接口如下：</p>\n<pre><code class=\"language-javascript\">    mapDispatchToProps = (dispatch, ownProps) => {}\n</code></pre>\n<p>如上这里的<code>dispatch</code>就是<code>redux</code>中的<code>dispatch</code>，当我们需要改变<code>state</code>的时候，就需要<code>dispatch action</code>，在<code>connect</code>中如果没有传入<code>mapDispatchToProps</code>的话，会将<code>dispatch</code>作为<code>props</code>传入组件；<code>mapDispatchToProps</code>的函数的返回值是一个<code>object</code>，函数的<code>value</code>就是一个<code>action creator</code>：</p>\n<pre><code class=\"language-javascript\">    const mapDispatchToProps = (dispatch) => {\n        return ({\n            foo: (payload) => { dispatch(myAcion(payload)) },\n        });\n    }\n</code></pre>\n<p>如上，这里的<code>foo</code>在组件中可以通过<code>props</code>访问到，这里最好将组件中的<code>action creator</code>放在<code>mapDispatchToProps</code>中，不要暴露<code>dispatch</code>到组件中，避免将<code>redux</code>暴露给组件中，这样组件对<code>redux</code>是无感的，组件的复用性更高。\n如下，如果一个组件需要从<code>store</code>上获取数据，使用<code>connect</code>将组件包起来：</p>\n<pre><code class=\"language-javascript\">    connect()(MyComponent);\n    connect(\n        mapState,\n        null,\n        mergeProps,\n        options)(MyComponent);\n</code></pre>\n<p>如上的方式使用<code>connect</code>，<code>MyComponent</code>中的<code>props</code>就可以拿到<code>dispatch</code>。\n就像上面说的，并不推荐直接将<code>dispatch</code>直接传给组件，将<code>action creator</code>包装成一个函数传给组件：</p>\n<pre><code class=\"language-javascript\">    const mapStateToProps = (state, props) => {\n        ......\n    };\n    \n    const mapDispatchToProps = (dispatch) => {\n        return ({\n            increment: () => dispatch({type: '  INCREASE'}),\n            decrement: () => dispatch({type: 'DESCREASE'}),\n        }),\n    }\n    connect(mapStateToProps, mapDispatchToProps)(MyComponent);\n</code></pre>\n<p><code>ConnectAdvanced</code>是<code>react-redux</code>提供的最后一个<code>API</code>，这个<code>API</code>是5.0之后提供的，这个方法主要是提供定制化的<code>connect</code>，由开发者自己实现缓存和<code>props check</code>，<code>connect</code>内部就是使用<code>connectAdvanced</code>实现，它也是一个高阶组件，其函数接口如下：</p>\n<pre><code class=\"language-javascript\">    connectAdvanced(selectorFactory, connectOptions?)\n</code></pre>\n<p>如上，其中的<code>selectorFactory</code>就是产生<code>mapStateToProps + mapDispatchToProps</code>的工厂函数，起接口及其作用如下：</p>\n<pre><code class=\"language-javascript\">    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps\n</code></pre>\n<p>我们会在<code>(dispatch, options) => {}</code>这一层将我们的<code>action creator</code>函数以及最终传给组件的<code>props</code>对象创建好，在第二层闭包<code>nextState, nextOwnProps</code>中会在<code>redux state</code>刷新的时候拿到最新的<code>state</code>和<code>props</code>，在这一层会做缓存的命中，如果最新的<code>props</code>中变更的数据影响当前组件，会更新在第一层闭包中缓存好的最终需要传给组件的<code>props</code>。</p>\n<pre><code class=\"language-javascript\">    import * as actionCreators from './actionCreators'\nimport { bindActionCreators } from 'redux'\n\nfunction selectorFactory(dispatch) {\n  let ownProps = {}\n  let result = {}\n\n  const actions = bindActionCreators(actionCreators, dispatch)\n  const addTodo = text => actions.addTodo(ownProps.userId, text)\n\n  return (nextState, nextOwnProps) => {\n    const todos = nextState.todos[nextOwnProps.userId]\n    const nextResult = { ...nextOwnProps, todos, addTodo }\n    ownProps = nextOwnProps\n    if (!shallowEqual(result, nextResult)) result = nextResult\n    return result\n  }\n}\nexport default connectAdvanced(selectorFactory)(TodoApp)\n</code></pre>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"如何使用React—Redux","date":"January 19, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-1-19-HowReactReduxWorks/","previous":{"fields":{"slug":"/2019-1-12-HowToBuildYourOwnTimeSystem/"},"frontmatter":{"title":"我是怎样构建自己的时间管理系统的","category":"Life"}},"next":{"fields":{"slug":"/2019-1-26-ReactRedux源码解读/"},"frontmatter":{"title":"React-Redux源码剖析","category":"Tech"}}}}