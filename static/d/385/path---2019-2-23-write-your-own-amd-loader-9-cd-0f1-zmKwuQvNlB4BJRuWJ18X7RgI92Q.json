{"data":{"site":{"siteMetadata":{"title":"Bee starter","author":"[Your Name]","siteUrl":"https://gatsby-starter-bee.netlify.com","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"c715c185-acce-5ce5-a0ec-e94e4a0be89e","excerpt":"上一篇博客 Javascript模块化 介绍了前端的模块化的一些方案和历史，基于浏览器的 规范 ，我们尝试自己实现一个 。 AMD Loader要解决的问题 主要是为了解决浏览器端的模块化，实现 的话，以下的点要考虑到： 前端的加载是异步的 模块的依赖也是模块（可能会出现循环依赖的问题） 每个Module只加载一次 暴露  和 其实我们主要要解决的点在于，如何处理 的加载。 加载要解决两个主要问题，一是对模块的引用（对path…","html":"<p>上一篇博客<a href=\"http://cuteshilina.com/2019/02/06/Javascript%E6%A8%A1%E5%9D%97%E5%8C%96/\">Javascript模块化</a>介绍了前端的模块化的一些方案和历史，基于浏览器的<a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\"><code class=\"language-text\">AMD</code>规范</a>，我们尝试自己实现一个<code class=\"language-text\">AMD Loader</code>。</p>\n<h1 id=\"amd-loader要解决的问题\"><a href=\"#amd-loader%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\" aria-label=\"amd loader要解决的问题 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AMD Loader要解决的问题</h1>\n<p><code class=\"language-text\">AMD</code>主要是为了解决浏览器端的模块化，实现<code class=\"language-text\">AMD Loader</code>的话，以下的点要考虑到：</p>\n<ul>\n<li>前端的加载是异步的</li>\n<li>模块的依赖也是模块（可能会出现循环依赖的问题）</li>\n<li>每个Module只加载一次</li>\n<li><code class=\"language-text\">AMD Loader</code>暴露 <code class=\"language-text\">define</code>和<code class=\"language-text\">require</code></li>\n</ul>\n<p>其实我们主要要解决的点在于，如何处理<code class=\"language-text\">Module</code>的加载。<code class=\"language-text\">Module</code>加载要解决两个主要问题，一是对模块的引用（对path的处理）；二是如何维护模块之间的引用关系。</p>\n<h1 id=\"模块代码的加载\"><a href=\"#%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8A%A0%E8%BD%BD\" aria-label=\"模块代码的加载 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>模块代码的加载</h1>\n<p>首先来看看<code class=\"language-text\">define</code>的<code class=\"language-text\">API</code>接口：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span>id<span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> dependence<span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> factory<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">define</code>的函数中<code class=\"language-text\">id</code>是表示当前模块的<code class=\"language-text\">id</code>，<strong><code class=\"language-text\">id</code>可以是字符串或者一个绝对路径的字符串</strong>，这里规定不能出现相对<code class=\"language-text\">id</code>，例如’./myModule’或者 ‘../myModule’；<code class=\"language-text\">id</code>是可选的，如果没有提供<code class=\"language-text\">id</code>的话，默认<code class=\"language-text\">id</code>名是<code class=\"language-text\">Module</code>的在浏览器加载当前<code class=\"language-text\">Module</code>的<code class=\"language-text\">url</code>。\n<code class=\"language-text\">dependence</code>，是一个字符串数组，字符串是依赖模块的<code class=\"language-text\">url</code>，可以是相对路径、绝对路径、字符串（如JQuery）。\n所以，我们首先要解决的问题是，如何去规范化用户传进来的各种各样的<code class=\"language-text\">url</code>，例如，下面这些<code class=\"language-text\">url</code>的规范化：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"> <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>a<span class=\"token operator\">/</span>b<span class=\"token operator\">/</span>c<span class=\"token comment\">//d --> a/b/c/d</span>\n <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>a<span class=\"token operator\">/</span>b<span class=\"token operator\">/</span>c<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>d <span class=\"token operator\">--</span><span class=\"token operator\">></span> <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>a<span class=\"token operator\">/</span>d\n <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>a<span class=\"token operator\">/</span>b<span class=\"token operator\">/</span>c<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>d <span class=\"token operator\">--</span><span class=\"token operator\">></span> <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>a<span class=\"token operator\">/</span>b<span class=\"token operator\">/</span>c<span class=\"token operator\">/</span>d\n main<span class=\"token operator\">/</span>test<span class=\"token operator\">?</span>foo#bar <span class=\"token operator\">--</span><span class=\"token operator\">></span> main<span class=\"token operator\">/</span>test</code></pre></div>\n<p>对于这些<code class=\"language-text\">URl</code>，我们可以写正则表达式去匹配，在用户传入模块的’url’，需要过一遍我们的正则，将其规范化，对于依赖模块，我们要基于当前<code class=\"language-text\">Config</code>的<code class=\"language-text\">baseURL</code>（如果在config中配置了baseUrl的话），拼成完整的<code class=\"language-text\">url</code>，让浏览器的<code class=\"language-text\">script</code>去加载，在加载完之后，将对应的<code class=\"language-text\">script</code>删除。</p>\n<div class=\"gatsby-highlight\" data-language=\"script\"><pre class=\"language-script\"><code class=\"language-script\">    function loadScript(url, callback) {\n        var node = document.createElement(&#39;script&#39;);\n        var head = document.head;\n        node.setAttribute(&#39;data-module&#39;, url);\n        node.async = true;\n        node.src = url;\n        \n        function onload() {\n            node.onload = node.onerror = null;\n            head.removeChild(node);\n            callback();\n        }\n        node.onerror = function(error) {\n            node.onload = node.onerror = null;\n            head.removeChild(node);\n            callback(error)\n        }\n    }</code></pre></div>\n<p>如上，是使用<code class=\"language-text\">script</code>标签加载模块的一些代码，基本逻辑是：</p>\n<p><code class=\"language-text\">创建script标签 ---&gt; 加载模块源码 ---&gt; 模块加载完成后触发回调函数</code></p>\n<p>这里主要是利用<code class=\"language-text\">script</code>标签来做模块的加载，这里给<code class=\"language-text\">script</code>标签加上了<code class=\"language-text\">async=true</code>的标志，浏览器在解析<code class=\"language-text\">HTML</code>页面的时候，不会因为加载<code class=\"language-text\">script</code>阻塞住页面的解析，在<code class=\"language-text\">script</code>加载成功后执行<code class=\"language-text\">script</code>中的代码。</p>\n<h1 id=\"模块的定义\"><a href=\"#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9A%E4%B9%89\" aria-label=\"模块的定义 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>模块的定义</h1>\n<p>在使用<code class=\"language-text\">AMD Loader</code>定义我们的<code class=\"language-text\">Module</code>的时候，使用<code class=\"language-text\">define(id?, dependence?, factory)</code>的接口来定义我们的<code class=\"language-text\">Module</code>，在实现模块定义的时候，我们可以预想到有以下问题：</p>\n<ul>\n<li>模块的加载是异步的，意味着我们需要设计<code class=\"language-text\">notify</code>机制</li>\n<li>我们需要解决模块循环依赖问题</li>\n<li>模块仅仅被加载一次，需要有模块的<code class=\"language-text\">cache</code></li>\n</ul>\n<p><img src=\"http://Soyn.github.io/img/main.png\">\n如上，对于<code class=\"language-text\">main Module</code>有<code class=\"language-text\">dep0, dep1, dep2</code>三个依赖，这里我们在定义<code class=\"language-text\">main Module</code>的时候，将<code class=\"language-text\">main Module</code>中的每个依赖（在声明中只有url）实例化成<code class=\"language-text\">Module</code>，在加载<code class=\"language-text\">main Module</code>的时候，得先要加载我们的依赖<code class=\"language-text\">Module</code>，这里因为<code class=\"language-text\">Module</code>的加载是异步的，所以在实例化我们的依赖的时候，在每个<code class=\"language-text\">Module</code>中保存一个<code class=\"language-text\">refs</code>的数组，这个数组中保存着依赖这个<code class=\"language-text\">Module</code>的<code class=\"language-text\">id</code>，当前<code class=\"language-text\">Module</code>加载完成之后，在<code class=\"language-text\">onload</code>的<code class=\"language-text\">callback</code>中去通知当前模块<code class=\"language-text\">load</code>完成，然后当前<code class=\"language-text\">Module</code>会查看当前<code class=\"language-text\">Module</code>的<code class=\"language-text\">refs</code>中所有的<code class=\"language-text\">Module</code>，在<code class=\"language-text\">refs</code>中这些<code class=\"language-text\">Module</code>就会收集自己所有的依赖是不是都加载完成，如果加载完成了，当前的<code class=\"language-text\">Module</code>就加载完成了，否则就触发当前<code class=\"language-text\">ref</code>的重新<code class=\"language-text\">load</code>（为了触发其他未被加载的依赖的加载）。</p>\n<p>解决了<code class=\"language-text\">notify</code>的问题，剩下的两个问题主要是对<code class=\"language-text\">Module</code>状态的维护，如下图，是整个<code class=\"language-text\">Module</code>的加载的状态转移图：\n<img src=\"http://Soyn.github.io/img/AMDLoader.png\"></p>\n<p>依照上图的状态转移图，<code class=\"language-text\">Module Class</code>的设计如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Module</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> deps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>refs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>depsUrl <span class=\"token operator\">=</span> <span class=\"token function\">getVaildUrl</span><span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>depsModule <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token constant\">STATUS</span> <span class=\"token operator\">=</span> <span class=\"token constant\">STATUS</span><span class=\"token punctuation\">.</span><span class=\"token constant\">INIT</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nModule<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    constructor<span class=\"token punctuation\">:</span> Module<span class=\"token punctuation\">,</span>\n    fetch<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 加载module的代码</span>\n    save<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>depsUrl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 检测修正依赖的url，并剔除已经被加载的module的url</span>\n    resolve<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 实例化每个依赖</span>\n    setDependencies<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 设置依赖当前模块的refs</span>\n    checkCircular<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 检测循环依赖</span>\n    makeExports<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 调用Module的factory函数并输出exports</span>\n    load<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 加载模块</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>对于Module本身来说我们这里也需要维护一个状态，来表明当前<code class=\"language-text\">Module</code>的执行状态：</p>\n<p><code class=\"language-text\">init --&gt; fetch --&gt; save --&gt; load --&gt; executing --&gt; executed or error</code></p>\n<p><code class=\"language-text\">AMD-Loader</code>的完整代码 —> <a href=\"https://github.com/Soyn/AMDLoader/blob/master/src/index.js\">AMD Loader</a>，<strong>代码实现仅为了解AMD模块加载的原理，并不能用在生产环境下</strong>。</p>\n<h1 id=\"reference\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<ul>\n<li><a href=\"https://github.com/creeperyang/blog/issues/17\">AMD加载器分析与实现</a></li>\n<li><a href=\"https://github.com/creeperyang/amd-loader/blob/master/amd.js\">https://github.com/creeperyang/amd-loader/blob/master/amd.js</a></li>\n<li><a href=\"https://github.com/requirejs/requirejs/blob/master/require.js\">requireJS源码</a></li>\n</ul>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"自己动手写AMD Loader","date":"February 23, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-2-23-WriteYourOwnAmdLoader/","previous":{"fields":{"slug":"/2019-2-06-Javascript模块化/"},"frontmatter":{"title":"Javascript模块化","category":"Frontend Javascript"}},"next":{"fields":{"slug":"/development/quick_start/"},"frontmatter":{"title":"Quick Start","category":"development"}}}}