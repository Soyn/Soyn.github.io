{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"1603dad0-daf7-5b01-b867-3f3dd035b4be","excerpt":"TL;DR; 前端打包中会将多个module打包成一个bundle发给客户端，但是各个module中存在并不会使用到的东西，dead code elimination是一种可以消除这些代码的技术 Tree Shaking是Dead code elimination（简称DCE）的一种实现 Webpack中的tree shaking需要es6的 import/export 的支持 Webpack中的tree shaking仅仅能作用与顶层函数、顶层变量、顶层对象，如果定义一个函数集合的Object…","html":"<h2>TL;DR;</h2>\n<ul>\n<li>\n<p>前端打包中会将多个module打包成一个bundle发给客户端，但是各个module中存在并不会使用到的东西，dead code elimination是一种可以消除这些代码的技术</p>\n</li>\n<li>\n<p>Tree Shaking是Dead code elimination（简称DCE）的一种实现</p>\n</li>\n<li>\n<p>Webpack中的tree shaking需要es6的<code>import/export</code>的支持</p>\n</li>\n<li>\n<p>Webpack中的tree shaking仅仅能作用与顶层函数、顶层变量、顶层对象，如果定义一个函数集合的Object，如果仅仅只使用了一部分函数，其他的函数仍然会被打进去</p>\n<h2>什么是Tree Shaking</h2>\n<p>在前端开发的过程中，一般整个代码会分散在项目的各个模块中，但是在最后在发送给客户端的时候，往往是一个大的bundle文件，各个模块的文件打包成一个JS文件，但是伴随而来的问题就是，某些永远跑不到的代码也会打到最后的bundle文件中，这就无形中增加了bundle的size。\n<code>Dead code elimination（简称DCE）</code>是一种可以消除最后编译产物中无用的代码的技术，就以上出现的问题DCE技术可以移除无用的不相关的代码，以达到减小产物size的作用。</p>\n<pre><code class=\"language-javascript\">function add(a, b) {\n    const c = a + b;\n    return c;\n    const m = a * b;  // unreachable code\n    return m;\n}\n\nfunction bar(a, b) {\n    const c = a * b;\n    if(0) {  // unreachable code\n        // do something\n    }\n}\n</code></pre>\n<p>以上的代码就是一个典型的可以通过<code>DCE</code>消除掉的例子，但是在前端<code>webpack</code>中可以消除掉这些永远跑不到的代码，但是存在一个问题就是如果你<code>import</code>了一个模块，这个模块暴露出了两个函数，你在运行时只使用了其中一个，那么在最后打包的时候另外一个函数也会被打进去，代码如下：</p>\n<pre><code class=\"language-javascript\">// helper.js\nexport function foo() {\n    return 'foo';\n}\nexport function bar() {\n    return 'bar';\n}\n\n// main.js\nimport {foo} from './helpers';\nconsole.log(foo());\n</code></pre>\n<p>如上在这种情况下，我们只使用了<code>foo</code>函数，没有使用<code>bar</code>函数，最后使用<code>webpack</code>打包之后，我们不需要<code>bar</code>函数的代码，因为没人去调用它，但是<code>webpack</code>如果没有配置<code>tree shaking</code>的话，<code>bar</code>还是会被打进最后的<code>bundle</code>。\n<code>tree shaking</code>就是一种<code>DCE</code>技术，发源于<code>Lisp</code>，最早在JS中是在<code>google closure</code>中使用，后来<code>rollup</code>的作者在<code>rollup</code>中引入了<code>tree shaking</code>这个技术，同时在<code>webpack4</code>中也实现了相应的功能。</p>\n<h2>Tree Shaking的限制</h2>\n<p><code>Tree Shaking</code>的原理简单来说，就是程序的执行能够被一颗由函数调用组成的树表示，如果一个函数没有被调用到，那么这个函数就可以被消除掉；但是在<code>commonJS</code>中，<code>module</code>的加载不是静态的，这时候去做静态语法分析是比较困难的，但是<code>es6 moudle</code>的出现，使得这个问题变简单了，所以<code>tree shaking</code>的先决条件是你的<code>module</code>使用的是<code>es6</code>的<code>import/export</code>。</p>\n<h2>Tree Shaking在Webpack中的使用</h2>\n<p>配置<code>webpack babel loader</code>的插件：</p>\n<pre><code class=\"language-javascript\"> {\n         loader: 'babel-loader',\n         test: dir_js,\n         query: {\n         // presets: ['es2015'],\n\n        // All of the plugins of babel-preset-es2015,\n        // minus babel-plugin-transform-es2015-modules-commonjs\n        plugins: [\n          // 'babel-plugin-transform-es2015-modules-commonjs',\n          'transform-es2015-template-literals',\n          'transform-es2015-literals',\n          'transform-es2015-function-name',\n          'transform-es2015-arrow-functions',\n          'transform-es2015-block-scoped-functions',\n          'transform-es2015-classes',\n          'transform-es2015-object-super',\n          'transform-es2015-shorthand-properties',\n          'transform-es2015-computed-properties',\n          'transform-es2015-for-of',\n          'transform-es2015-sticky-regex',\n          'transform-es2015-unicode-regex',\n          'check-es2015-constants',\n          'transform-es2015-spread',\n          'transform-es2015-parameters',\n          'transform-es2015-destructuring',\n          'transform-es2015-block-scoping',\n          'transform-es2015-typeof-symbol',\n          ['transform-regenerator', { async: false, asyncGenerators: false }],\n        ],\n            },\n        }\n</code></pre>\n<p>如果要让<code>tree shaking</code>起作用，那么将es6插件中的<code>babel-plugin-transform-es2015-modules-commonjs</code>去掉，避免打成<code>commonJS</code>的包，不然<code>tree shaking</code>没用。</p>\n<p>如下我们有以下代码，我们使用<code>webpack</code>来编译它们，来看看使用<code>tree shaking</code>和不使用的区别：</p>\n<pre><code class=\"language-javascript\">    // helper.js\n    export function foo() {\n    if(0) {\n      console.log('unreachable code');\n    }\n    return 'foo';\n}\nexport function bar() {\n    return 'bar';\n}\n\n// main.js\nimport {foo} from './helpers';\nlet elem = document.getElementById('output');\nconsole.log('test');\nconsole.log(foo)\nelem.innerHTML = `Output: ${foo()}`;\n</code></pre>\n<p>使用<code>webpack</code>编译后的部分代码：</p>\n<p><img src=\"./images/tree-shaking-webpack0.png\"></p>\n<p>如上图是在没有启用<code>tree-shaking</code>的时候打包之后的<code>bundle</code>，这里在最后的<code>bundle</code>文件中有没有使用的<code>bar</code>函数，下图是使用了<code>tree shaking</code>之后打包后的代码：</p>\n<p><img src=\"./images/tree-shaking-webpack1.png\"></p>\n<p>可以看到在没有<code>tree shaking</code>的情况下没有使用的<code>bar</code>函数的代码也被打进了最后的<code>bundle</code>中，使用了<code>tree shaking</code>的将没有使用到的函数消除掉了。</p>\n</li>\n</ul>\n<h2>Tree Shaking真的很美好吗？</h2>\n<p>  看到这里你可能觉得<code>tree shaking</code>真的很美好，能够帮你把一切在运行时没有使用到的代码消除掉，但是遗憾的是，在实际情况下并没有这么美好，看看下面的例子：</p>\n<pre><code class=\"language-javascript\">    // helper.js\n  // top level function\n  export function foo() {\n    if(0) {\n        console.log('unreachable code');    \n    }\n    return 'foo';\n    }\n    export function bar() {\n    return 'bar';\n    }\n    \n  // top level object\n    export const MyObject = {\n    fooFuncInObj: () => {\n        return 'foo in obj';\n    },\n    barFuncInObj: () => {\n        return 'bar in obj';\n    },\n    };\n    \n  \n    export const MyObject1 = {\n    fooFuncInObj: () => {\n        return 'foo in obj';\n    },\n    barFuncInObj: () => {\n        return 'bar in obj';\n    },    \n    };\n    \n  // top level variable\n    export const fooVar = \"I'm top level variable foo\";\n  export const barVar = \"I'm top level variable bar\";\n    export const varObj = {\n    foo: 'variable foo in varObj',\n      barVar: \"variable bar in varObj\",\n    };\n</code></pre>\n<pre><code class=\"language-javascript\">import { foo, MyObject, fooVar, varObj } from './helpers';\nlet elem = document.getElementById('output');\nelem.innerHTML = `Output0: ${foo()} \\n Output1: ${MyObject.fooFuncInObj()} \\n Output2: ${fooVar}\\n Output1: ${varObj.foo}`;\n</code></pre>\n<p>  如果<code>tree shaking</code>足够聪明，那么我们这里仅仅调用了<code>MyObject</code>下的一个函数，另外一个函数没有使用，同样的我们只使用了<code>varObj</code>下的一个变量，另外的变量不应该打到最后的<code>bundle</code>里面去，遗憾的是现实情况并不是这样，下图是<code>webpack</code>打出来的包：</p>\n<p>  <img src=\"./images/tree-shaking-webpack2.png\"></p>\n<p>  从上面的代码我们可以有这样的结论，<code>webpack</code>的<code>tree shaking</code>对顶层函数、顶层变量和顶层对象有作用。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Tree_shaking\">https://en.wikipedia.org/wiki/Tree_shaking</a></li>\n<li><a href=\"https://github.com/rauschma/tree-shaking-demo\">https://github.com/rauschma/tree-shaking-demo</a></li>\n<li><a href=\"http://2ality.com/2015/12/webpack-tree-shaking.html\">http://2ality.com/2015/12/webpack-tree-shaking.html</a></li>\n</ul>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"Tree Shaking","date":"December 22, 2018"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2018-12-22-TreeShaking/","previous":{"fields":{"slug":"/2018-12-15-集成Sonarqube到项目/"},"frontmatter":{"title":"集成SonarQube到你的项目中","category":"Tech"}},"next":{"fields":{"slug":"/2018-12-29-Reselect/"},"frontmatter":{"title":"如何使用Reselect做性能优化","category":"Tech"}}}}