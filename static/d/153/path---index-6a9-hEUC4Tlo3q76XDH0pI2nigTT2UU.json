{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"Problem 我们先来看一个 Demo （切到 0.5x）: 在上面的 Demo 中，在 touchStart 的事件的 callback 中跑了一段 JS 的循环，打开 Chrome 的 devtools ，切换到移动端的模式，在页面上滑动的时候，可以明显感觉到左边盒子的滚动有明显的延迟和卡顿，而右边的盒子滚动起来却很顺滑；这两个盒子的 touchStart 事件的 callback 跑的循…","fields":{"slug":"/tech/平滑滚动/"},"frontmatter":{"date":"March 21, 2020","title":"使用Passive event保证平滑滚动","category":"tech"}}},{"node":{"excerpt":"在前端的学习中，经常会听到双向绑定（ MVVM ）这个概念，双向绑定的概念很简单，就是视图（ View ）上的更新能够实时更新数据层（ Model ），同时数据层的更新也会实时更新到视图层。不同于 MVC 的数据单向流动（从数据层到视图层），那么如何实现数据和视图的双向绑定呢？\n实现数据的双向绑定，首先我们要搞明白面临的问题： 如何监听试图层的变化？ 视图层变化之后如何更新到数据层？ 如何监听数…","fields":{"slug":"/2019-6-15-mvvm/"},"frontmatter":{"date":"June 15, 2019","title":"双向绑定","category":"Tech"}}},{"node":{"excerpt":"什么是同源策略 \n上面是 Wikipedia 对同源策略的定义，简单来说同源策略就是限制不同的源（ Domain ）之间的交互的安全策略。想象如果没有同源策略的限制，你访问银行的网站A时的登录信息，在你访问另一个网站B的时候，B网站可以拿到A网站的信息，如果B网站有恶意的代码，就可以直接访问你的银行账户。\n同源策略中的同源，是三个相同： 协议相同 域名相同 端口号相同 以 http://www.…","fields":{"slug":"/2019-5-11-sameOriginPolicy/"},"frontmatter":{"date":"May 11, 2019","title":"浏览器同源策略","category":"Tech"}}},{"node":{"excerpt":"什么是Promise？ Promise 英文翻译过来是诺言、承诺的意思 顾名思义， Promise 的潜在含义是： promise 代表的是还没发生的事 在事情没有完成之前，无法确定是成功还是失败 而在 Javascript 中的 Promise 代表的意义是类似的，对于异步操作（网络请求、文件I/O等）这些事情在完成之前无法确定其状态，在完成的时候要么成功要么失败， Promise 会在完成的…","fields":{"slug":"/2019-4-20-Promise/"},"frontmatter":{"date":"April 20, 2019","title":"Promise初探","category":"Tech"}}},{"node":{"excerpt":"什么是路由？ 路由最一开始是在后端中出现的，我们在访问某些网站的时候经常会见到类似于这样的 url :\n http://www.xxx.com/xxx.php  或者  http://www.xxx.com/xxx.html ，这就是 SSR （Server Side Render）服务端渲染，通过后端直接渲染前端页面。这里客户端会发向服务端发请求，服务端解析 url ，根据 url 将需要的资…","fields":{"slug":"/2019-4-13-frontend-route/"},"frontmatter":{"date":"April 13, 2019","title":"前端路由","category":"Tech"}}},{"node":{"excerpt":"在前端开发中，如何对前端状态的管理是一个需要面对的问题，前端主要是数据展示和界面交互， 交互的存在就会导致数据的变化，数据的变化会影响页面的展示 ，也就是说，一个完整的前端状态管理，要提供数据的存储、更新、数据变化的通知机制。这篇文章，我们来了解一下如何从0到1，如何实现前端数据的管理。 发布订阅 首先我们需要一个机制在数据更新的时候，用到这份数据的部分能够知道数据更新了，这样才能保证页面的同步…","fields":{"slug":"/2019-3-23-StateManager/"},"frontmatter":{"date":"March 23, 2019","title":"实现一个前端状态管理库","category":"Tech"}}},{"node":{"excerpt":"在ES6之前， Javascript 并没有官方标准的模块化方案，在社区中就出现了 Common.js 和 AMD 这两种方案，前者主要用于服务端，后者用在浏览器端，为了统一写法，又出现了 UMD 的标准，在 ES6 中， Javascript 终于有了官方标准的模块化方案，这篇博客我们就来看看 ES6 的模块化方案。 Overview 定义和使用模块 如上，是 ES6 中 Module 的用法…","fields":{"slug":"/2019-3-16-ESModule/"},"frontmatter":{"date":"March 16, 2019","title":"ES6 Module","category":"Tech"}}},{"node":{"excerpt":"在访问网页的时候，浏览器是如何渲染当前的页面的？浏览器获取到输入（ HTML 、 CSS 、 Javascript ）的时候，输入中有 DOM Tree 的信息，有样式信息， Javascript 代码，在加载页面的时候，如果 DOM 的加载和解析太耗时的话，首屏的大量留白是很影响用户体验的，这里我们来看看，对于 Scritp 在页面中的加载对 HTML 的加载的性能影响。 Script在页面中…","fields":{"slug":"/2019-3-2-AsyncAndDeferInScript/"},"frontmatter":{"date":"March 02, 2019","title":"script在HTML中的加载","category":"Tech"}}},{"node":{"excerpt":"上一篇博客 Javascript模块化 介绍了前端的模块化的一些方案和历史，基于浏览器的 AMD 规范 ，我们尝试自己实现一个 AMD Loader 。 AMD Loader要解决的问题 AMD 主要是为了解决浏览器端的模块化，实现 AMD Loader 的话，以下的点要考虑到： 前端的加载是异步的 模块的依赖也是模块（可能会出现循环依赖的问题） 每个Module只加载一次 AMD Loader…","fields":{"slug":"/2019-2-23-WriteYourOwnAmdLoader/"},"frontmatter":{"date":"February 23, 2019","title":"自己动手写AMD Loader","category":"Tech"}}},{"node":{"excerpt":"TL:DR; 前端模块化主要是解决依赖管理，模块加载的问题 立即调用函数的匿名闭包是模块化实现的基石 在客户端和服务端都需要做模块化 CommonJS是服务端的模块化解决方案，模块同步加载 AMD是客户端（浏览器）的模块化方案，模块异步加载 UMD统一了客户端和服务端，兼容AMD和CommonJS ES6提供了官方的模块化（import/export）  在写 Javascript 的时候，会经…","fields":{"slug":"/2019-2-06-Javascript模块化/"},"frontmatter":{"date":"February 06, 2019","title":"Javascript模块化","category":"Tech"}}},{"node":{"excerpt":"TL;DR; Connect 本质上是一个高阶组件 Connect 会对组件做缓存控制 Connect 使用 Context 做全局状态的通信 Overview 如上，react-redux向外暴露了四个API，分别是 Provider 、 ConnectAdvanced 、 ReactReduxContext 、 connect 。 Provider Provider 是一个 React Co…","fields":{"slug":"/2019-1-26-ReactRedux源码解读/"},"frontmatter":{"date":"January 26, 2019","title":"React-Redux源码剖析","category":"Tech"}}},{"node":{"excerpt":"在构建基于 Redux 的 React 应用的时候，我们往往需要使用 React-Redux 做数据绑定，当 Redux 中的数据刷新的时候，通知所有用到数据的组建刷新， React-Redux 提供了对 React 组件的订阅发布的能力。 我们为什么需要React-Redux 如果你熟悉 Redux 的话，我们知道在 Redux 中我们会维护一个全局的 store ， store 中存储了当前…","fields":{"slug":"/2019-1-19-HowReactReduxWorks/"},"frontmatter":{"date":"January 19, 2019","title":"如何使用React—Redux","category":"Tech"}}},{"node":{"excerpt":"工作之后，自己的个人时间就变的少了，不像上学的时候那样有很多时间能自由安排，刚参加工作的时候自己的时间管理更是混乱，经常性的就是觉得这个周什么都没干，一个周就过去了，做事学东西也没有一个好的进度和时间的跟踪，在意识到这个问题之后，决定改变这个不好的习惯，自己也建立了一套自己的时间管理系统，很好的改善了当前的情况。这里主要是介绍自己的一些使用的工具，以及如何使用这些应用规划自己的时间。 Googl…","fields":{"slug":"/2019-1-12-HowToBuildYourOwnTimeSystem/"},"frontmatter":{"date":"January 12, 2019","title":"我是怎样构建自己的时间管理系统的","category":"Life"}}},{"node":{"excerpt":"TL;DR; 在 React 、 Redux 的应用中，使用 Reselect 来做性能优化是常见的优化手段 Reselect 默认只有一份 cache ， cache 命中的策略是浅比较，引用改变了会导致 cache 失效 Reselect 支持定制 memeoize 函数和 cache 命中策略 在开发 React 前端应用的时候，我们经常会使用 Redux 做状态管理，但是随着前端代码的复…","fields":{"slug":"/2018-12-29-Reselect/"},"frontmatter":{"date":"December 29, 2018","title":"如何使用Reselect做性能优化","category":"Tech"}}},{"node":{"excerpt":"TL;DR; 前端打包中会将多个module打包成一个bundle发给客户端，但是各个module中存在并不会使用到的东西，dead code elimination是一种可以消除这些代码的技术 Tree Shaking是Dead code elimination（简称DCE）的一种实现 Webpack中的tree shaking需要es6的 import/export 的支持 Webpack中…","fields":{"slug":"/2018-12-22-TreeShaking/"},"frontmatter":{"date":"December 22, 2018","title":"Tree Shaking","category":"Tech"}}},{"node":{"excerpt":"在整个项目的开发过程中，开发人员在编写代码之前，往往会制定相关的代码规范，虽然写完代码之后有code review的过程，但是难免会有code review发现不了的问题，往往一些潜在的bug或者坏味道的代码会出现在项目中,\b这时候如果有一个自动\b检查代码规范的工具，\b就能有效的避免一些问题，SonarQube就是提供了这样一个能力的工具\b，\b刚好前段时间我负责集成SonarQube\u001c的服务到我…","fields":{"slug":"/2018-12-15-集成Sonarqube到项目/"},"frontmatter":{"date":"December 15, 2018","title":"集成SonarQube到你的项目中","category":"Tech"}}},{"node":{"excerpt":"2018就这样过去了，从参加工作到现在，也工作也一年多了，现在自己也不再像刚毕业一样，在面对工作生活中的出现的一些麻烦问题慌张，不知所措，但是同时也要面对更复杂和麻烦的问题；2018年初的时候自己定过一些目标，虽然并没有100%都完成掉，但是主线都是在向这个目标靠近；在这一年里自己也有很多对工作、生活、学习的思考。 2018的目标完成了多少？ \n上图是当时在18年初定的目标，先说一说年初的时候为…","fields":{"slug":"/2018-1-05-MyYearOf2018/"},"frontmatter":{"date":"January 05, 2018","title":"My Year Of 2018","category":"Life"}}},{"node":{"excerpt":"    偶然的一个机会了解到V2EX这个网站，顺手搜了一下V站创始人的信息， Livid（刘昕）是谁？ ，Livid中文名刘昕，V2EX论坛作者。顺道看了一下Livid的一篇文章 26岁写给18岁的自己 我知道现在的自己是再也回不去的了。可是倘若有机会，我是多么希望能让 18 岁的你在一个晴朗的，没有负担的午后读到这封信，并且多么希望你能够将它读上好多遍。 这样的场景或许只会发生在奇幻电影中，2…","fields":{"slug":"/2016-11-26-写给25岁的自己/"},"frontmatter":{"date":"November 26, 2016","title":"在21岁的时候写给25岁的自己","category":"Life"}}},{"node":{"excerpt":"    找工作的事情总算是告一段落，在资本寒冬来临的时候，自己也是十分好运的搭上了互联网的末班车，比起身边其他人，我找工作的过程也没有多艰辛，暑期的时候同学内推了现在的公司，然后视频面试，两轮技术面，一轮hr面，9月初的时候拿到了意向offer，9月底的时候拿到了正式的聘用书，拿到意向offer后基本上就没跑过招聘会，但是等到9月底的时候实在是等到崩溃了，在学校笔试了几个公司，去西电笔试了一场，…","fields":{"slug":"/2016-10-02-愿路途不再往复，愿无岁月可回头/"},"frontmatter":{"date":"October 02, 2016","title":"愿路途不再往复","category":"Life"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}