{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"573bb285-2551-5253-9836-8f103ca7adc3","excerpt":"什么是Promise？ Promise 英文翻译过来是诺言、承诺的意思 顾名思义， Promise 的潜在含义是： promise 代表的是还没发生的事 在事情没有完成之前，无法确定是成功还是失败 而在 Javascript 中的 Promise 代表的意义是类似的，对于异步操作（网络请求、文件I/O等）这些事情在完成之前无法确定其状态，在完成的时候要么成功要么失败， Promise 会在完成的时候通知你。 上面是 Promise 的定义， Promise…","html":"<h1>什么是Promise？</h1>\n<p><code>Promise</code>英文翻译过来是诺言、承诺的意思</p>\n<p><img src=\"./images/promise_0.png\"></p>\n<p>顾名思义，<code>Promise</code>的潜在含义是：</p>\n<ul>\n<li><code>promise</code>代表的是还没发生的事</li>\n<li>在事情没有完成之前，无法确定是成功还是失败</li>\n</ul>\n<p>而在<code>Javascript</code>中的<code>Promise</code>代表的意义是类似的，对于异步操作（网络请求、文件I/O等）这些事情在完成之前无法确定其状态，在完成的时候要么成功要么失败，<code>Promise</code>会在完成的时候通知你。</p>\n<p><img src=\"./images/promise_1.png\"></p>\n<p>上面是<code>Promise</code>的定义，<code>Promise</code>是一个表示异步事件处理完成的对象，我们看看传统的异步操作是怎样的：</p>\n<pre><code class=\"language-javascript\">    function successCallback(result) {\n        console.log('Result is ready: ', result);\n    }\n    \n    function failureCallback(error) {\n        console.log('Error on async request: ', error);\n    }\n    requestData(options, sucessCallback, failureCallback)\n</code></pre>\n<p>在传统的异步操作下，整个接口的定义实现方式，没有一个清晰的定义，不同的人去写，接口的定义方式不一样。</p>\n<pre><code class=\"language-javascript\">    function successCallback(result) {\n        console.log('Result is ready: ', result);\n    }\n    \n    function failureCallback(error) {\n        console.log('Error on async request: ', error);\n    }\n    requestData(options).then(successCallback).catch(failureCallback)\n</code></pre>\n<p>在<code>Promise</code>中，抽象出了异步操作成功（then）的接口和失败的接口（catch/reject），并且支持链式调用，在传统的<code>callback</code>的实现中，如果下一个异步操作依赖于上一个操作，很容易写出<code>callback hell</code>的这种代码，对于代码的阅读和维护带来麻烦。</p>\n<h1>Promise的状态</h1>\n<p><code>Promise</code>对象对象是一个代理对象，被代理的值表示一个异步操作，在创建的时候，对于最终异步操作的返回结果是未知的，<code>Promise</code>允许为异步操作的成功和失败分别绑定相应的处理方法，让异步方法可以像同步方法一样返回值，但并不是立即返回最终的执行结果，而是一个代理了未来出现的结果的<code>Promise</code>对象，<code>Promise</code>有以下几种状态：</p>\n<ul>\n<li><code>pending:</code>初始状态，创建<code>promise</code>之后，执行还没结束的时候</li>\n<li><code>fulfilled：</code>异步操作成功</li>\n<li><code>rejected:</code>异步操作失败</li>\n</ul>\n<p><img src=\"./images/promise_2.png\"></p>\n<p>如上图，在<code>promise</code>创建后，所处的状态为<code>pending</code>状态，执行成功或失败的这个过程叫<code>settled</code>，<code>settled</code>之后，<code>promise</code>由<code>pending</code>状态转换到<code>fulfilled</code>或<code>rejected</code>状态，并执行相应的回调。</p>\n<h1>How to use Promise?</h1>\n<p>我们首先来看看<code>Promise</code>提供的方法：</p>\n<h2>Constructor</h2>\n<p>常见的方式是通过<code>Promise</code>的构造函数得到Promise的实例：</p>\n<pre><code class=\"language-javascript\">    function executor(resolve, reject) {\n        const r = asyncWork();\n        r.on('success', (s) => {\n            resolve(s);\n        })\n        r.on('error', (e) => {\n            reject(e);\n        })\n    }\n     const p = Promise(executor)\n</code></pre>\n<p>如上<code>Promise</code>的构造函数接收一个<code>executor</code>函数为参数，这个<code>executor</code>一般来说是一个异步操作，在生成实例的时候会被执行，在执行成功的时候调用<code>resolve</code>，失败的时候调用<code>reject</code>。</p>\n<h2>实例方法</h2>\n<ul>\n<li><code>Promise.prototype.then(onFulfilled?, onRejected?)</code>，在<code>promise resolve</code>的时候<code>onFulfilled</code>会被调用，<code>reject</code>的时候<code>onReject</code>会被调用，这两个参数是可选的，如果你只想对异常进行处理的话，可以使用<code>promise.then(undefined, onRejected)</code></li>\n<li><code>Promise.prototype.catch(onRejected)</code>，<code>catch</code>方法会在<code>promise reject</code>的时候被调用。</li>\n<li><code>Promise.prototype.finally(onFinally)</code>，向当前<code>promise</code>添加一个回调函数，无论当前<code>promise</code>的状态是完成还是失败都会被调用</li>\n</ul>\n<h2>静态方法</h2>\n<ul>\n<li><code>Promise.resolve(value)</code>，返回一个由给定<code>value</code>决定的<code>promise</code>对象；如果这个<code>value</code>可以是一个<code>thenable</code>的对象（带有<code>then</code>方法的对象），最终返回的<code>promise</code>对象的状态由<code>then</code>方法执行决定；否则的话，返回的<code>promise</code>对象状态为<code>fulfilled</code>，并且将该值传给对应的<code>then</code>方法，如果你不知道一个值是否是<code>Promise</code>对象，使用<code>Promise.resolve(value)</code>来返回一个<code>Promise</code>对象，这样就能将该<code>value</code>以<code>Promise</code>对象的形式使用。</li>\n<li><code>Promise.reject(reason)</code>，返回一个执行状态为<code>rejected</code>的<code>Promise</code>对象，并将错误信息给到对应的处理函数</li>\n<li><code>Promise.race(iterable)</code>，当<code>iterable</code>中的任意一个子<code>promise</code>成功或者失败后，父<code>promise</code>会使用这个子<code>promise</code>的结果，传给父<code>promise</code>绑定的回调上</li>\n<li><code>Promise.all(iterable)</code>，这个方法返回一个<code>promise</code>对象，只有<code>iterable</code>中所有的<code>promise</code>执行成功的时候才会触发成功，一旦由任何一个执行失败都会触发要返回这个<code>promise</code>额失败，最终<code>iterable</code>的返回结果和<code>iterable</code>的顺序一致。</li>\n</ul>\n<p><code>promise</code>是支持链式调用的：</p>\n<pre><code class=\"language-javascript\">    Promise.resolve({\n      then: (resolve, reject) => {\n        resolve(1);\n      }\n    })\n    .then((r) => {\n      console.log(r)\n    })\n    .then(() => {\n      console.log(2)\n    })\n    .finally(() => {\n      console.log(3)\n    })\n    .then(() => {\n      console.log(4)\n    })\n</code></pre>\n<h2>Promise的错误处理</h2>\n<pre><code class=\"language-javascript\">    // use `catch`\n    new Promise((resolve, reject) => {\n      console.log('Init')\n      resolve()\n    })\n    .then(() => {\n      throw new Error('error')  // {A}\n    })\n    .then(() => { // {B}\n        console.log('123');\n    })\n    .catch(() => {\n      console.log('Error was caught!')\n    })\n    .then(() => {\n      console.log('End')\n    })\n    \n    // use reject\n    new Promise((resolve, reject) => {\n      console.log('Init')\n      resolve()\n    })\n    .then(() => {\n      throw new Error('error')\n    })\n    .then(() => {\n      console.log('End')\n    }, () => {\n      console.log('Error was caught!')\n    })\n</code></pre>\n<p><code>promise</code>在处理错误的时候，可以通过<code>Promise.ptototype.catch</code>或者是注册的<code>reject</code>方法来处理错误，在<code>{A}</code>行处，抛出了错误，这里<code>promise</code>的状态会变为<code>rejected</code>，会调用对应的回调函数，在<code>{A}</code>到<code>.catch</code>之间的<code>promise</code>链会被打断。</p>\n<h1>Wraaper by Promise</h1>\n<pre><code class=\"language-javascript\">    function delay(ms) {\n        return new Promise((resolve, reject) => {\n            setTimeout(resolve, ms);\n        })\n    }\n</code></pre>\n<p>我们在使用<code>setTimeout</code>的时候，<code>setTimeout</code>执行的函数如果执行发生了错误，并且在函数的实现中并没有做<code>Error Handling</code>，函数执行发生错误的时机我们并不知道，如果使用上面基于<code>promise</code>包裹之后的<code>timeout</code>，我们是可以明确知道错误发生的时机的。</p>\n<h2>超时Promise</h2>\n<p><code>promise</code>创建之后，会等待异步操作的执行，如果异步操作的时间很长的话，这个<code>promise</code>一直处于  <code>pending</code>状态，对于用户来说，页面会一直停留在<code>loading</code>的状态，显然，用户体验并不好，因此，对于这种情况，我们需要提供可以在超时之后，取消<code>promsie</code>的机制：</p>\n<pre><code class=\"language-javascript\">    function delayPromise(ms) {\n        return delay(ms).then(() => {\n            console.error('Operation is timeout!');\n        })\n    }\n    function timeoutPromise = (asyncFn, ms) {\n        return Promise.race([\n            new Promise(asyncFn),\n            delayPromise(ms)\n        ]);\n    }\n</code></pre>\n<p>如上我们基于<code>Promise.race</code>实现了超时<code>promise</code>。</p>\n<h2>Refrence</h2>\n<ul>\n<li><a href=\"http://liubin.org/promises-book/\">Promise迷你书</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a></li>\n</ul>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"Promise初探","date":"April 20, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-4-20-Promise/","previous":{"fields":{"slug":"/2019-4-13-frontend-route/"},"frontmatter":{"title":"前端路由","category":"Tech"}},"next":{"fields":{"slug":"/2019-5-11-sameOriginPolicy/"},"frontmatter":{"title":"浏览器同源策略","category":"Tech"}}}}