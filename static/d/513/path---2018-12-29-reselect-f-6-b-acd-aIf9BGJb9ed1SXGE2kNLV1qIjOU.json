{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"b3e3fe75-7708-5773-bb38-3e2b068ea71a","excerpt":"TL;DR; 在 React 、 Redux 的应用中，使用 Reselect 来做性能优化是常见的优化手段 Reselect 默认只有一份 cache ， cache 命中的策略是浅比较，引用改变了会导致 cache 失效 Reselect 支持定制 memeoize 函数和 cache 命中策略 在开发 React 前端应用的时候，我们经常会使用 Redux 做状态管理，但是随着前端代码的复杂度的上升，会引入 Reselect 作为性能优化的手段之一，这篇文章就Reselect的一些应用场景作一些介绍。 什么是Selector…","html":"<p>TL;DR;</p>\n<ul>\n<li>在<code>React</code>、<code>Redux</code>的应用中，使用<code>Reselect</code>来做性能优化是常见的优化手段</li>\n<li><code>Reselect</code>默认只有一份<code>cache</code>，<code>cache</code>命中的策略是浅比较，引用改变了会导致<code>cache</code>失效</li>\n<li>\n<h2><code>Reselect</code>支持定制<code>memeoize</code>函数和<code>cache</code>命中策略</h2>\n<p>在开发<code>React</code>前端应用的时候，我们经常会使用<code>Redux</code>做状态管理，但是随着前端代码的复杂度的上升，会引入<code>Reselect</code>作为性能优化的手段之一，这篇文章就Reselect的一些应用场景作一些介绍。</p>\n<h2>什么是Selector</h2>\n<p>在介绍<code>Reselect</code>的之前，我们首先要知道<code>Selector</code>这个概念，那么什么是<code>Selector</code>呢？\n<code>Selector</code>这个概念并不是<code>Javascrip</code>t或者<code>React</code>、<code>Redux</code>的一个概念。想象一下你去便利店买可乐，你给店员说要可口可可，这时候店员就去给你拿一罐可口可乐，这时候，店员其实就是充当了<code>Selector</code>的角色，店员知道如何从各种商品里拿到你要的可口可乐，具体来说<code>Selctor</code>有以下特点：</p>\n</li>\n<li><code>Selector</code>知道从哪里，以及如何去获取数据的子集</li>\n<li>\n<p><code>Selector</code>会返回数据的子集\n用代码来表示就是：</p>\n<pre><code class=\"language-javascript\">const getCoke = (state) => state.shop.items.coke\n</code></pre>\n<h2>为什么我们需要Selector？</h2>\n<p>简单来说<code>Selector</code>就是从一个大的<code>State</code>上去获取子数据的函数，其实就是从一个大的<code>Object</code>，根据指定的<code>path</code>去取数据，如果自己不写<code>Selector</code>，也可以在用的地方从<code>state</code>上去取，但是这样存在的一个问题是，如果有多个地方都需要同一份数据，你不得不在多个地方加同样的代码，如果<code>State</code>的结构变了，那么这样就会取修改多个文件的代码，可维护性并不高，所以从可维护性的角度来说，<code>Selector</code>是很有必要的。\n同样随着项目复杂度的提升，我们会有很多个<code>Selector</code>，针对于获取数据粒度，不同的<code>Selector</code>是可以组合成更复杂的`Selector<code></code>。</p>\n<h2>为什么要在项目中引入Reselector</h2>\n<p>简单来说就是为了性能，因为<code>Reselector</code>给<code>Selector</code>提供了缓存的能力，避免了重复计算；在一个复杂的<code>Redux</code>的Web App中，在<code>state</code>发生变化的时候，会依次调用所有的<code>connect</code>，从理论上来说我们只应该去刷新和变化数据相关的组件，但是可能会存在这种情况，某些<code>connect</code>中要获取的数据虽然没变，但是如果每次connect每次都返回一个新的引用，那么就会导致无谓的重刷；还存在的问题是，在<code>connect</code>中回去数据的逻辑是很耗时的操作，导致性能瓶颈。这两个问题字实际的开发中，是很常见的问题，<code>Reselect</code>可以在一定程度上解决这些意外的问题。</p>\n</li>\n</ul>\n<h2>如何使用Reselector</h2>\n<p>我们通过一个例子来看看，来看看<code>Reselect</code>是如何提升性能的。</p>\n<pre><code class=\"language-javascript\">import React, { Component } from 'react';\nimport { connect } from 'react-redux'\n\nexport const countReducer = (state = {}, action) => {\n  switch (action.type) {\n    case 'INCREASE_1':\n      return {\n        ...state,\n        demo_1: {\n          count: state.demo_1.count + 1,\n        }\n      };\n    case 'INCREASE_2':\n      return {\n        ...state,\n        demo_2: {\n          count: state.demo_2.count + 1,\n        }\n      }\n    default:\n      return {\n        ...state,\n        demo_1: {\n          count: 0,\n        },\n        demo_2: {\n          count: 0,\n        }\n\n      }\n  }\n}\nexport const increase_1 = () => ({\n  type: 'INCREASE_1',\n});\nexport const increase_2 = () => ({\n  type: 'INCREASE_2',\n});\nconst mapStateToProps1 = (state) => {\n  const demo1 = { ...state.demo_1 };\n  return {\n    demoData: demo1,//demoDataSelector(state, 'demo_1'),\n  }\n}\nconst mapStateToProps2 = (state, props) => {\n  const demo2 = { ...state.demo_2 };\n  return {\n    demoData: demo2,\n  }\n}\nclass CardView1 extends Component {\n  render() {\n    console.log('...render cardview1');\n    return (&#x3C;div className=\"card\" style={{\n      backgroundColor: 'red',\n      width: '150px',\n      height: '50px',\n      display: 'inline-block',\n      color: 'white',\n    }}>{`Cardview1 CurrentView: ${this.props.demoData.count}`}&#x3C;/div>);\n  }\n}\nclass CardView2 extends Component {\n  render() {\n    console.log('...render cardview2');\n    return (&#x3C;div className=\"card\"style={{\n      backgroundColor: 'blue',\n      width: '150px',\n      height: '50px',\n      display: 'inline-block',\n      marginLeft: '10px',\n      color: 'white',\n    }}>{`Cardview2 CurrentView: ${this.props.demoData.count}`}&#x3C;/div>);\n  }\n}\nconst connected = {\n  CardView1: connect(mapStateToProps1)(CardView1),\n  CardView2: connect(mapStateToProps2)(CardView2),\n}\n\nclass Counter extends Component {\n  render() {\n    return (\n      &#x3C;div id=\"app-container\" style={{\n        textAlign: 'center',\n      }}>\n        &#x3C;h1>\n          &#x3C;button className=\"count1\" onClick={() => {\n            this.props.dispatch(increase_1());\n          }}>Increase Card 1&#x3C;/button>\n          &#x3C;button className=\"count2\" onClick={() => {\n            this.props.dispatch(increase_2());\n          }}>Increase Card 2&#x3C;/button>\n        &#x3C;/h1>\n        &#x3C;connected.CardView1/>\n        &#x3C;connected.CardView2/>\n      &#x3C;/div>\n    );\n  }\n}\nexport default connect()(Counter);\n</code></pre>\n<p>在上面的代码中，<code>Cardview1</code>和<code>CardView2</code>每次会从<code>state</code>上取出数据，然后放到一个新的<code>Object</code>上去，导致每次都会产生一个新的引用，那么这里会导致的问题是，在我们更新<code>demo_1</code>的数据的时候理当只刷新<code>Cardview1</code>，但是在上面代码的情况下，刷新<code>Cardview1</code>的时候也会刷新<code>Cardview2</code>，反之亦然；当我点击\n这里存在的问题是，在<code>mapStateToProps</code>中，每次都返回了一个新的引用，所以导致虽然和组件中无关的属性更新了，但是仍然刷新了；这里我们使用<code>Reselect</code>将<code>mapStateToProps</code>中的<code>Selector</code>包一下：</p>\n<pre><code class=\"language-javascript\">const getDemoData = (state, key) => {\n  return state[key];\n}\nconst demoDataSelector = createSelector(getDemoData, data => data);\nconst mapStateToProps1 = (state) => {\n  return {\n    demoData: demoDataSelector(state, 'demo_1'),\n  }\n}\nconst mapStateToProps2 = (state, props) => {\n  return {\n    demoData: demoDataSelector(state, 'demo_2'),\n  }\n}\n</code></pre>\n<p>这里的话使用<code>Reselect</code>来解决这个问题，这里虽然这个例子不大合适，但是这里仅仅是以这个为例子来讲解<code>Reselect</code>的用法。</p>\n<h2>如何在复用的组件中使用Reselect？</h2>\n<p>如果一个使用了<code>Reselect</code>的组件在多个地方使用，那么其实这个组件的优化是无意义的，因为在生成下一个组件的实例的时候会将上一个组件的<code>cache</code>冲掉，如下：</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport ShopItems from './components/shopitems';\n\nconst Shop = () => {\n    &#x3C;div>\n        &#x3C;ShopItems category=\"belts\" />\n        &#x3C;ShopItems category=\"dresses\" />\n        &#x3C;ShopItems category=\"pants\" />\n    &#x3C;/div>\n    }\n</code></pre>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport { connect } from 'react-redux';\nimport { createSelector } from 'reselect';\n\nconst getItemsByCategory = (state,props) => state.items[props.category];\n\nconst getItemsSelector = createSelector(getItemsByCategory, items => items);\nconst ShopItems = () => {\n    return (this.props.items.map(item => {\n        &#x3C;div>{item}&#x3C;/div>\n    }));\n}\nexport default connect(getItemsSelector)(ShopItems);\n</code></pre>\n<p>如上，这里复用了<code>ShopItems</code>这个组件，这个组件使用的<code>Selector</code>使用了<code>Reselect</code>，但是这里的优化是没什么卵用的，因为对于<code>Selector</code>来说每次的参数都变化了，<code>cache</code>并不会命中，所有我们需要在<strong>每一次实例化组件的时候，为每一个组件生成一份<code>cache</code></strong>，如下：</p>\n<pre><code class=\"language-javascript\">const makeGetItemsSelector = () => {\n    return createSelector(getItemsByCategory, items => items);\n}\nconst makeMapStateToProps = () => {\n    const getItems = makeGetItemsSelector();\n    const mapStateToProps = (state, props) => {\n        return {\n            items: getItems(state, props),\n        }\n    }\n}\n\n// ...\n\nexport connect(makeMapStateToProps)(ShopItems);\n</code></pre>\n<p>如上，这里会为每一个组件生成一个私有的<code>Selector</code>，就可以避免在复用组件的时候，<code>cache</code>没有做对的问题。</p>\n<h2>使用Reselect生成结构化的数据</h2>\n<p>考虑下面的代码：</p>\n<pre><code class=\"language-javascript\">const mySelectorA = state => state.a\nconst mySelectorB = state => state.b\n\n// The result function in the following selector\n// is simply building an object from the input selectors\nconst structuredSelector = createSelector(\n   mySelectorA,\n   mySelectorB,\n   mySelectorC,\n   (a, b, c) => ({\n     a,\n     b,\n     c\n   })\n)\n</code></pre>\n<p>这里最后需要生成一个结构化的数据，这种情况下，<code>Reselect</code>提供了生成结构化的数据的<code>API</code>—> <code>createStructuredSelector</code>。</p>\n<pre><code class=\"language-javascript\">const mySelectorA = state => state.a\nconst mySelectorB = state => state.b\n\nconst structuredSelector = createStructuredSelector({\n  x: mySelectorA,\n  y: mySelectorB\n})\n\nconst result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\n</code></pre>\n<h2>定制createSelector</h2>\n<p>因为默认的<code>createSelector</code>的只提供了一份<code>cache</code>，在很多情况下并不满足我们的需求，另外<code>cache</code>的命中策略是浅比较，在一些情况下并不适用我们的使用场景，所以<code>Reselect</code>提供了定制<code>createSelector</code>的能力 —><code>createSelectorCreator(memoize, ...memoizeOptions)</code>。如下，我们使用<code>lodash</code>生成一个一个无限<code>cache</code>的<code>createSelector</code>。</p>\n<pre><code class=\"language-javascript\">const mySelectorCreator = createSelectorCreator(_.memoize);\n</code></pre>\n<p>如上，我们就拥有了一个无限<code>cache</code>的<code>selectorCreator</code>。</p>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"如何使用Reselect做性能优化","date":"December 29, 2018"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2018-12-29-Reselect/","previous":{"fields":{"slug":"/2018-12-22-TreeShaking/"},"frontmatter":{"title":"Tree Shaking","category":"Tech"}},"next":{"fields":{"slug":"/2019-1-12-HowToBuildYourOwnTimeSystem/"},"frontmatter":{"title":"我是怎样构建自己的时间管理系统的","category":"Life"}}}}