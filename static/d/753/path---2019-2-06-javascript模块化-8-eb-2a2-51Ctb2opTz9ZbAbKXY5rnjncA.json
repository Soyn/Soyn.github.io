{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"258cb764-8bba-5917-a949-c6c3ce544c95","excerpt":"TL:DR; 前端模块化主要是解决依赖管理，模块加载的问题 立即调用函数的匿名闭包是模块化实现的基石 在客户端和服务端都需要做模块化 CommonJS是服务端的模块化解决方案，模块同步加载 AMD是客户端（浏览器）的模块化方案，模块异步加载 UMD统一了客户端和服务端，兼容AMD和CommonJS ES6提供了官方的模块化（import/export）  在写 Javascript 的时候，会经常会听到模块化这个概念，模块化在编程是一个很重要的设计，将可复用的、独立的模块抽出来，一是避免重复造轮子；二是减小维护和使用成本，虽然现在 ES…","html":"<hr>\n<p>TL:DR;</p>\n<ul>\n<li>前端模块化主要是解决依赖管理，模块加载的问题</li>\n<li>立即调用函数的匿名闭包是模块化实现的基石</li>\n<li>在客户端和服务端都需要做模块化</li>\n<li>CommonJS是服务端的模块化解决方案，模块同步加载</li>\n<li>AMD是客户端（浏览器）的模块化方案，模块异步加载</li>\n<li>UMD统一了客户端和服务端，兼容AMD和CommonJS</li>\n<li>ES6提供了官方的模块化（import/export）</li>\n</ul>\n<hr>\n<p> 在写<code>Javascript</code>的时候，会经常会听到模块化这个概念，模块化在编程是一个很重要的设计，将可复用的、独立的模块抽出来，一是避免重复造轮子；二是减小维护和使用成本，虽然现在<code>ES6</code>提供了标准的模块化方案，但是在<code>Javascript</code>的发展历程中还是经历了一段从黑暗到光明的阶段。</p>\n<h2>模块的加载和封装</h2>\n<p>使用<code>&#x3C;script></code>来做模块化最常见的方式是使用<code>script</code>标签将你需要的模块在网页中加载，在用户请求网页的时候，会加载前置的依赖，例如这样：</p>\n<pre><code class=\"language-html\">  &#x3C;html>\n    &#x3C;head>\n      &#x3C;script type=\"text/javascript\" src=\"./module1.js\">&#x3C;/script>\n      &#x3C;script type=\"text/javascript\" src=\"./main.js\">&#x3C;/script>\n    &#x3C;/head>\n    &#x3C;body>&#x3C;/body>\n  &#x3C;/html>\n</code></pre>\n<p>就像上面一样，这里先加载<code>module1.js</code>，在<code>main.js</code>中会使用<code>module1</code>暴露出的方法，但是这样的模块化方案如果面对大量的依赖管理的话，就会面临很多问题，就像下面的代码：</p>\n<pre><code class=\"language-html\">  &#x3C;html>\n    &#x3C;head>\n      &#x3C;script type=\"text/javascript\" src=\"./framework.js\">&#x3C;/script>\n      &#x3C;script type=\"text/javascript\" src=\"./frameworkPlugin.js\">&#x3C;/script>\n      &#x3C;script type=\"text/javascript\" src=\"./frameworkPlugin1.js\">&#x3C;/script>\n      &#x3C;script type=\"text/javascript\" src=\"./frameworkPlugin2.js\">&#x3C;/script>\n      &#x3C;script type=\"text/javascript\" src=\"./frameworkPlugin3.js\">&#x3C;/script>\n      ...\n      &#x3C;script type=\"text/javascript\" src=\"./main.js\">&#x3C;/script>\n    &#x3C;/head>\n    &#x3C;body>&#x3C;/body>\n  &#x3C;/html>\n</code></pre>\n<p>但是如果依赖多了的话，带来的问题就是，第一依赖模糊，模块与模块之间的依赖并不清楚；第二就是会给代码维护带来麻烦，因为在编写代码的时候，依赖的注入，是依赖于<code>html</code>中前置的<code>script</code>标签做的，在代码中并没有显示的声明依赖；第三就是每个<code>&#x3C;script></code>加载都需要发网络请求，这里网络请求过多。</p>\n<p>如何构建<code>Javascript</code>模块也是一个值得探讨的问题，常见的是这样：</p>\n<pre><code class=\"language-javascript\">function foo() {\n    ......\n}\n\nfunction bar() {\n    ......\n}\n</code></pre>\n<p>如果以为上面的方式暴露接口的话，存在的问题就是，很容易污染全局环境，造成命名冲突，为了解决命名冲突的问题，随之而来，我们可以增加命名空间：</p>\n<pre><code class=\"language-javascript\">const myModule = {\n    foo: function () { ... },\n    bar: function () { ... },\n}\n\nmyModule.foo()\n</code></pre>\n<p>像上面这样加命名空间的方式减少了全局环境被污染的情况，并且这样的封装并不安全，本质上是对象，外部可以访问到不想暴露给外界的东西，这种方式并没有解决根本矛盾—>保证封装性的同时减少全局变量的数量，在这里我们要保证模块只暴露想暴露的东西，一些私有属性外界无法访问，这里使用闭包就可以解决这些问题：</p>\n<pre><code class=\"language-javascript\">const myModule = (function(){\n    const _private = 1;\n    const foo = () => {\n        // use _private\n    }\n    return {\n        foo,\n    }\n})();\nmyModule.foo()\nmyModule._private\n</code></pre>\n<p>这里使用立即调用（IIFE）的模式，将私有属性和外部隔离起来，保证了封装性，如果我们需要注入其他的依赖可以这样：</p>\n<pre><code class=\"language-javascript\">const myModule = (function($){\n    const _$ = $;\n    const _private = 1;\n    const foo = (selector) => {\n        return _$(selector);\n    }\n    return {\n        foo,\n    }\n})($)\n</code></pre>\n<p>就像上面的代码，如果可以向模块引入外部依赖，这就是现代模块系统的基石。</p>\n<p>上面讲了如何封装一个模块和加载模块，在实际的开发过程中，我们仍然需要考虑几个问题，比如跳出浏览器环境，在<code>Node.js</code>下如何做模块化，如何对打包之后的模块进行压缩、合并、优化。</p>\n<h2>CommonJS</h2>\n<p><code>CommonJS</code>是<code>Node.js</code>的模块化规范，<code>Common.js</code>对外暴露四个环境变量<code>module</code>、<code>exports</code>、<code>global</code>、<code>require</code>，<code>Common.js</code>以文件作为独立模块来管理，<code>Common.js</code>以同步的方式加载模块。</p>\n<pre><code class=\"language-javascript\">//  引入模块\n// a.js\nconst foo = () => {\n    ...\n}\nconst bar = () => {\n    ...\n}\n\n// 导出模块\nmodule.exports = {\n    foo,\n    bar\n}\n\n// main.js\n// 声明依赖模块\nconst { foo, bar } = reauire(./a.js);\n\nfoo();\nbar();\n</code></pre>\n<p>因为在服务端，文件存在磁盘上，读取速度很快，同步的加载方式不存在问题，但是在浏览器上，因为网络的原因，同步加载的方式并不是一个好的方式，这就引入了异步加载模块的方式<code>AMD</code>。</p>\n<p>优缺点：</p>\n<ul>\n<li>服务端的模块化方案实现</li>\n<li>模块的输出是<code>Object</code>，无法做静态分析</li>\n<li>每个模块输出都是一个<code>copy</code>，无法做到热加载</li>\n<li>循环依赖的管理做的不好</li>\n</ul>\n<h2>AMD（Async Module Definition ）</h2>\n<p><code>AMD</code>规范制定了一套异步加载<code>module</code>的机制，<code>define(id?, dependencies?, factory)</code>，<code>define</code>函数的前两个参数是可选的，如果提供了一个<code>id</code>，这个<code>id</code>就代表该模块，如果没有给这个参数，某块的名字就是模块加载器请求脚本的名字，<code>dependencies</code>是一个模块<code>id</code>的数组，声明当前模块的依赖模块，<code>factory</code>函数就是在所有依赖模块加载好之后的会调函数，如果<code>dependencies</code>中没有提供任何依赖，模块加载器会扫描<code>factory</code>函数中所有的<code>require</code>，同步加载依赖,<code>factory</code>函数只执行一次，如果传入的参数是一个<code>Object</code>的话，会将模块输出到这个对象中，如果函数的返回值是一个对象，模块输出到返回值中。</p>\n<pre><code class=\"language-javascript\">// 将alpha模块挂到exports上\n  define(\"alpha\", [\"require\", \"exports\", \"beta\"], function (require, exports, beta) {\n       exports.verb = function() {\n           return beta.verb();\n           //Or:\n           return require(\"beta\").verb();\n       }\n   });\n// 返回输出模块\n   define([\"alpha\"], function (alpha) {\n       return {\n         verb: function(){\n           return alpha.verb() + 2;\n         }\n       };\n   });\n// 一个没有依赖的模块\n   define({\n     add: function(x, y){\n       return x + y;\n     }\n   });\n// 使用commonJS包裹的模块\n   define(function (require, exports, module) {\n     var a = require('a'),\n         b = require('b');\n\n     exports.action = function () {};\n   });\n</code></pre>\n<p>优缺点：</p>\n<ul>\n<li>主要用于客户端（浏览器）</li>\n<li>语法复杂</li>\n</ul>\n<h2>UMD（Universal Module Definition）</h2>\n<p><code>AMD</code>和<code>CommonJS</code>的模块化方案提供两套<code>API</code>，<code>UMD</code>将这两套<code>API</code>统一了起来，<code>UMD</code>使用<code>commonJS</code>的语法，但是提供异步加载模块的能力。</p>\n<pre><code class=\"language-javascript\">    // File log.js\n(function (global, factory) {\n  if (typeof define === \"function\" &#x26;&#x26; define.amd) {\n    define([\"exports\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.log = mod.exports;\n  }\n})(this, function (exports) {\n  \"use strict\";\n\n  function log() {\n    console.log(\"Example of UMD module system\");\n  }\n  // expose log to other modules\n  exports.log = log;\n});\n</code></pre>\n<p>如上其实<code>UMD</code>就是对宿主环境做了兼容性处理，在不同的宿主环境下输出不同模块。</p>\n<p>优缺点：\n- 同时适用于客户端和服务端，兼容性好\n- 兼容<code>AMD</code>和<code>CommonJS</code></p>\n<h2>ES6的Import和Export</h2>\n<p>在<code>ES6</code>中有了官方的模块化解决方案，将<code>AMD</code>、<code>CommonJS</code>和<code>UMD</code>统一了起来，并且在打包工具打包的时候可以做静态分析，可以做<code>tree shaking</code>。</p>\n<pre><code class=\"language-javascript\">// a.js\nexport const foo = () => {}\n\n// main.js\nimport { foo } from './a';\nfoo();\n</code></pre>\n<p>优缺点：</p>\n<ul>\n<li>服务端和客户端都可以使用</li>\n<li><code>import</code>的时候拿到的是实际值不是拷贝，可以做热更新</li>\n<li>支持静态分析（可以用<code>tree shaking</code>）</li>\n<li>相比于<code>CommonJS</code>循环依赖的管理做的更好</li>\n</ul>\n<h2>Webpack 、Babel</h2>\n<p>因为并不是所有的宿主环境都支持<code>ES6</code>，我们需要使用<code>Babel</code>来将<code>ES6</code>的代码转移成<code>es5</code>的代码，同时我们需要对现有的工程代码做合并、压缩和优化，这主要是通过<code>Webpack</code>实现的，也可以使用<code>Webpack</code>做按需加载，划分不同的<code>chunk</code>，减少<code>http</code>请求。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://github.com/creeperyang/blog/issues/17\">https://github.com/creeperyang/blog/issues/17</a></li>\n<li><a href=\"https://github.com/Huxpro/js-module-7day\">https://github.com/Huxpro/js-module-7day</a></li>\n<li><a href=\"https://medium.freecodecamp.org/anatomy-of-js-module-systems-and-building-libraries-fadcd8dbd0e\">https://medium.freecodecamp.org/anatomy-of-js-module-systems-and-building-libraries-fadcd8dbd0e</a></li>\n</ul>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"Javascript模块化","date":"February 06, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-2-06-Javascript模块化/","previous":{"fields":{"slug":"/2019-1-26-ReactRedux源码解读/"},"frontmatter":{"title":"React-Redux源码剖析","category":"Tech"}},"next":{"fields":{"slug":"/2019-2-23-WriteYourOwnAmdLoader/"},"frontmatter":{"title":"自己动手写AMD Loader","category":"Tech"}}}}