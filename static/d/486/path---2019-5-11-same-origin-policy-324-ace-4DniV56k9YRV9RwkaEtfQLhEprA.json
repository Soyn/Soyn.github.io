{"data":{"site":{"siteMetadata":{"title":"Move fast and break things.","author":"wang yao","siteUrl":"http://cuteshilina.com/","comment":{"disqusShortName":"","utterances":"Soyn/Soyn.github.io.git"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"0f8fa345-1fc7-509e-9d21-7946c0293cef","excerpt":"什么是同源策略 \n上面是 Wikipedia 对同源策略的定义，简单来说同源策略就是限制不同的源（ Domain ）之间的交互的安全策略。想象如果没有同源策略的限制，你访问银行的网站A时的登录信息，在你访问另一个网站B的时候，B网站可以拿到A网站的信息，如果B网站有恶意的代码，就可以直接访问你的银行账户。\n同源策略中的同源，是三个相同： 协议相同 域名相同 端口号相同 以 http://www.example.com 为例： URL Outcome Reason http://www.example1.com Failure 域名不同 http…","html":"<h1>什么是同源策略</h1>\n<p><img src=\"./images/wiki.png\">\n上面是<code>Wikipedia</code>对同源策略的定义，简单来说同源策略就是限制不同的源（<code>Domain</code>）之间的交互的安全策略。想象如果没有同源策略的限制，你访问银行的网站A时的登录信息，在你访问另一个网站B的时候，B网站可以拿到A网站的信息，如果B网站有恶意的代码，就可以直接访问你的银行账户。\n同源策略中的同源，是三个相同：</p>\n<ul>\n<li>协议相同</li>\n<li>域名相同</li>\n<li>端口号相同</li>\n</ul>\n<p>以<code>http://www.example.com</code>为例：</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>Outcome</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://www.example1.com\">http://www.example1.com</a></td>\n<td>Failure</td>\n<td>域名不同</td>\n</tr>\n<tr>\n<td><a href=\"http://www.example.com:8080\">http://www.example.com:8080</a></td>\n<td>Failure</td>\n<td>端口号不同</td>\n</tr>\n<tr>\n<td><a href=\"http://www.example.com/dir/page.html\">http://www.example.com/dir/page.html</a></td>\n<td>Same Origin</td>\n<td>仅仅是path不同</td>\n</tr>\n<tr>\n<td><a href=\"https://www.example1.com\">https://www.example1.com</a></td>\n<td>Failure</td>\n<td>协议不同</td>\n</tr>\n</tbody>\n</table>\n<h1>同源策略限制的范围</h1>\n<p>同源策略对跨源访问的控制可以分为三类；</p>\n<ul>\n<li>对跨域资源的<code>写操作</code>是可以，例如表单提交、重定向这些不受同源策略的限制</li>\n<li>一些替换元素（img、audio、video等）不受同源策略的限制</li>\n<li>不同源之间的资源读操作（获取cookie、localStorage、DOM、AJAX请求等）受到同源策略的限制</li>\n</ul>\n<p>对于开发人员来说，第三条限制，跨域资源之间的读取受到限制，这个是最常遇见的问题，对于第二条中一些HTML原生标签不受跨域访问的限制，可以用来<code>hack</code>掉同源策略的限制，以下资源是不受同源策略限制的：</p>\n<ul>\n<li><code>&#x3C;script>标签</code></li>\n<li><code>外部CSS的加载&#x3C;link rel=\"stylesheet\" href=\"...\"></code></li>\n<li><code>&#x3C;Img>标签</code></li>\n<li><code>&#x3C;video>和&#x3C;audio>标签</code></li>\n<li><code>&#x3C;object>、&#x3C;embed>（&#x3C;applet>也不受同源策略限制，但该标签已经被废弃）</code></li>\n<li><code>@font-face引用的字体（浏览器实现有差异，有些要同源）</code></li>\n<li><code>&#x3C;iframe>中嵌入的内容</code></li>\n</ul>\n<h1>如何突破同源策略的限制</h1>\n<h2>Change Origin</h2>\n<p>在网页上可以通过设置<code>document.domain</code>设置当前页面所在的域，例如，在页面<code>http://store.company.com/dir/page.html</code>中的<code>JS</code>脚本执行了下面的代码：</p>\n<pre><code class=\"language-javascript\">document.domain = \"company.com\"；\n</code></pre>\n<p>那么在当前网站上去获取<code>http://www.company.com</code>的网站上的资源是不受同源策略的限制的，但是这个改变<code>domain</code>的方法仅仅用于二级域名获取一级域名的资源的时候，你不能在<code>http://www.company.com</code>的<code>domain</code>改变为<code>otherCompany.com</code>。</p>\n<h1>iframe</h1>\n<p><code>iframe</code>在的父子窗口如果不是同源的话，在访问获取彼此的DOM节点或者读取数据的话，会受到同源策略的限制，无法访问。\n<img src=\"./images/iframe.png\">\n父窗口所在的域为<code>http://localhost:5500</code>，其中子窗口所在的域为<code>http://localhost:8080</code>，这里父子窗口是同源的，所以彼此在获取资源的时候，会受到同源策略的限制：\n<img src=\"./images/parent.png\">\n<img src=\"./images/child.png\">\n对于<code>iframe</code>额跨域问题，有三种解决办法：</p>\n<ul>\n<li>使用<code>fragement</code>（hash tag）</li>\n<li>windows.name</li>\n<li>\n<p>postMessage</p>\n<h2>Fragement</h2>\n<p>这里的<code>fragement</code>指的是<code>url</code>中<code>#</code>后面的部分，在父窗口中把信息作为<code>hash</code>写入到子窗口的src上。</p>\n<pre><code class=\"language-javascript\">const originalSrc = document.getElementById('myFrame').src;\nconst src = originalSrc + '#' + data;\ndocument.getElementById('myFrame').location.replace(src);\n</code></pre>\n<p>因为<code>url hash</code>的改变不会引起页面的刷新，但是会触发<code>onhashchange</code>的事件，在子窗口中监听<code>onhashchange</code>的事件。</p>\n<pre><code class=\"language-javascript\">function getData() {\n  const data = window.location.hash;\n  ......\n}\nwindow.onhashchange = getData\n</code></pre>\n<p>同样，子窗口也可以通过同样的方式，向父窗口传递数据：</p>\n<pre><code class=\"language-javascript\">parent.location.replace(parentUrl + \"#\" + data);\n</code></pre>\n<h2><code>window.name</code></h2>\n<p><code>window.name</code>在页面进行跳转前设置的值，在跳转后也可以访问到，我们可以借助<code>window.name</code>的这个特性来解决跨域问题，整个流程如下：</p>\n</li>\n<li>在父窗口设置子<code>iframe</code>的<code>src</code>，在子窗口<code>load</code>成功后将<code>data</code>挂到<code>window.name</code>上，然后设置子窗口的<code>location.href</code>到与父窗口同域的页面</li>\n<li>\n<p>跳转到同域的页面后，父窗口就可以通过<code>window.name</code>拿到跨域页面设置的数据了\n例如：</p>\n<pre><code class=\"language-javascript\">a.com/index.html  // {A}\nb.com/index.html  // {B}\na.com/empty.html  // {C}\n</code></pre>\n<p>我们在<code>A</code>中加载完成后，在<code>A</code>页面中设置<code>src</code>为<code>B</code>页面的<code>url</code>，在<code>iframe</code>加载成功后，将数据设置到<code>window.name</code>上，然后改变自己的<code>location.href</code>为<code>C</code>页面，<code>C</code>页面加载成功后，<code>A</code>页面和<code>B</code>页面就是同源的了，这个时候<code>A</code>页面去子窗口上取<code>window.name</code>的值就不会因为跨域问题而报错了。 <strong>使用window.name的关键是在设置完window.name后，要将页面跳转到与父窗口同源的页面，这样主窗口才能访问子窗口上设置的数据</strong></p>\n<h2>window.postMessag</h2>\n<p><code>html5</code>提供了<code>postMessage</code>的机制，用于不同源之间的通信：</p>\n</li>\n</ul>\n<p><img src=\"./images/postMessage.png\" alt=\"postMessage MDN\"></p>\n<p><img src=\"./images/pm0.png\">\n在父窗口中监听<code>message</code>事件\n<img src=\"./images/pm1.png\">\n<code>iframe</code>窗口和父窗口不是同源的，通过<code>postMessage</code>将消息发送给父窗口。</p>\n<h2>JSONP</h2>\n<p>在浏览器中，<code>script</code>标签是可以从不同源的地址上加载而不受同源策略的限制，这就给我们提供了一种手段，绕过同源策略的限制，<code>JSONP</code>就是通过这种手段来达到跨域通信的，但是<code>JSONP</code>需要服务端的支持，将返回的<code>JSON</code>数据和<code>url</code>中的<code>callback</code>拼接起来，只要前端定义了这个函数，在浏览器看来，就是从服务端加载了一段带数据的函数调用。\n<img src=\"./images/JSONP0.png\">\n<img src=\"./images/JSONP1.png\"></p>\n<h2>CORS</h2>\n<p><code>CORS(cross-origin resource share)</code>规范了跨域请求的标准，通过<code>HTTP</code>头让浏览器允许跨域请求的发送，这个话题，我会在下一篇博客细讲。</p>\n<h2>Refrence</h2>\n<ul>\n<li><a href=\"https://medium.com/@baphemot/understanding-cors-18ad6b478e2b\">Understanding CORS – Bartosz Szczeciński – Medium</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\">浏览器同源政策及其规避方法</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">CORS</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/13\">跨域实践二三事</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\">CORS MDN</a></li>\n</ul>\n<hr>\n<p><strong><em>兴趣遍地都是，坚持和持之以恒才是稀缺的</em></strong></p>","frontmatter":{"title":"浏览器同源策略","date":"May 11, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-5-11-sameOriginPolicy/","previous":{"fields":{"slug":"/2019-4-20-Promise/"},"frontmatter":{"title":"Promise初探","category":"Tech"}},"next":{"fields":{"slug":"/2019-6-15-mvvm/"},"frontmatter":{"title":"双向绑定","category":"Tech"}}}}